<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>æ™ºèƒ½è¾¨è­˜å…¥åº« - ZXing-wasmå„ªå…ˆ + Tesseract v7 OCR fallbackï¼ˆGS1-128/UDIï¼‰</title>

<!-- âœ… é¿å…ç€è¦½å™¨ç¡¬æŠ“ /favicon.ico é€ æˆ 404 -->
<link rel="icon" href="data:,">

<style>
  body { font-family:-apple-system, sans-serif; padding:15px; background:#f4f4f9; text-align:center; margin:0; }
  .card { background:white; padding:15px; border-radius:15px; box-shadow:0 4px 15px rgba(0,0,0,0.1); max-width: 520px; margin: auto; }

  .btn-group { display: flex; gap: 10px; margin-top: 15px; }
  button { flex: 1; padding: 15px; border-radius: 10px; border: none; cursor: pointer; font-size: 16px; font-weight: bold; color: white; transition: 0.3s; }
  .btn-cam { background: #7360f2; }
  .btn-file { background: #2d9cdb; }
  .btn-snap { background: #27ae60; width: 100%; margin-top: 10px; font-size: 18px; }
  .btn-import { background: #27ae60; width: 100%; margin-top: 15px; font-size: 20px; box-shadow: 0 4px 10px rgba(39,174,96,0.3); }
  .btn-back { background: #666; width: auto; font-size: 14px; float: left; padding: 8px 15px; }

  /* âœ… ç›¸æ©Ÿé è¨­ç›´å‘é•·æ¢ (9:16)ï¼Œä½¿ç”¨è€…çŸ¥é“æ–¹å‘ */
  .camera-wrap {
    position: relative;
    width: 100%;
    aspect-ratio: 9/16;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #ddd;
    background:#000;
    margin-top: 15px;
    display: none;
  }

  video, #photoPreview { width:100%; height:100%; object-fit: cover; }
  #photoPreview { display: none; }

  .overlay { position:absolute; inset:0; pointer-events:none; }

  /* âœ… æ©«å‘ç´°æ¢æ¡†ï¼šæç¤ºã€Œæ¢ç¢¼è«‹æ©«æ”¾ã€ */
  .scan-box {
    position:absolute;
    left:50%;
    top:52%;
    transform:translate(-50%,-50%);
    width:92%;
    height:18%;
    border:1px solid rgba(255,255,255,0.28);
    border-radius:12px;
    box-shadow:0 0 0 9999px rgba(0,0,0,0.55);
  }

  .corner { position:absolute; width:20px; height:20px; border:4px solid #00ffb3; }
  .c1 { left:-2px; top:-2px; border-right:none; border-bottom:none; border-top-left-radius:12px; }
  .c2 { right:-2px; top:-2px; border-left:none; border-bottom:none; border-top-right-radius:12px; }
  .c3 { left:-2px; bottom:-2px; border-right:none; border-top:none; border-bottom-left-radius:12px; }
  .c4 { right:-2px; bottom:-2px; border-left:none; border-top:none; border-bottom-right-radius:12px; }
  .scan-line { position:absolute; left:5%; top:10%; width:90%; height:2px; background:linear-gradient(90deg,transparent,#00ffb3,transparent); animation: move 1.8s infinite; }
  @keyframes move { 0%, 100% { top: 10%; } 50% { top: 90%; } }

  .review-form { text-align: left; background: #f9f9ff; padding: 15px; border-radius: 12px; border: 2px solid #7360f2; margin-top: 15px; display: none; animation: fadeIn 0.5s; }
  @keyframes fadeIn { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }
  .review-form label { font-size: 13px; color: #555; font-weight: bold; display: block; margin-top: 10px; }
  .review-form input, .review-form select, .review-form textarea { width: 100%; padding: 12px; border: 1px solid #ccc; border-radius: 8px; font-size: 16px; box-sizing: border-box; margin-top: 4px; }

  .pill {
    display:inline-block; padding:6px 10px; border-radius:999px;
    background:#eef; color:#334; font-size:12px; font-weight:700;
    margin-top:10px;
  }

  .loader { display:none; margin:10px auto; width:30px; height:30px; border:3px solid #f3f3f3; border-top:3px solid #7360f2; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
  canvas#workCanvas { display:none; }
</style>
</head>

<body>
<div class="card">
  <button class="btn-back" onclick="location.href='index.html'">â¬…ï¸ è¿”å›ç¸½è¡¨</button>
  <div style="clear: both;"></div>
  <h2>ğŸ“¦ æ™ºèƒ½å…¥åº«è¤‡æ ¸</h2>

  <div class="btn-group" id="modeSelect">
    <button class="btn-cam" onclick="startCamera()">ğŸ“¸ é–‹å•Ÿç›¸æ©Ÿ</button>
    <button class="btn-file" onclick="document.getElementById('fileInput').click()">ğŸ“ ä¸Šå‚³ç…§ç‰‡</button>
  </div>
  <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileUpload(event)">

  <div class="camera-wrap" id="displayArea">
    <video id="video" autoplay muted playsinline></video>
    <img id="photoPreview" alt="preview">
    <div class="overlay" id="guidelines">
      <div class="scan-box">
        <div class="corner c1"></div><div class="corner c2"></div>
        <div class="corner c3"></div><div class="corner c4"></div>
        <div class="scan-line"></div>
      </div>
    </div>
  </div>

  <button id="btnSnap" class="btn-snap" onclick="takeSnapshot()" style="display:none;">ğŸ“¸ é»æ“Šæ‹ç…§ä¸¦åˆ†æ</button>

  <div class="loader" id="loader"></div>

  <div id="reviewArea" class="review-form">
    <h3 style="margin:0; color:#7360f2; border-bottom:1px solid #ddd; padding-bottom:8px;">ğŸ” è¾¨è­˜çµæœç¢ºèª</h3>

    <div class="pill" id="sourcePill">SOURCE: -</div>

    <label>åŸå§‹è¾¨è­˜å…¨æ–‡ï¼ˆZXing + OCRï¼‰ï¼š</label>
    <textarea id="rawAll"
      style="min-height:180px; font-size:13px; white-space:pre-wrap;"
      placeholder="å°šæœªè¾¨è­˜åˆ°ä»»ä½•æ–‡å­—"></textarea>

    <label>æ‰¹è™Ÿ (Lot/SN/UUID):</label>
    <input type="text" id="editLot" placeholder="å°šæœªåµæ¸¬">

    <label>æœ‰æ•ˆæ—¥æœŸ (æ ¼å¼: YYMMDD):</label>
    <input type="text" id="editExp" placeholder="å°šæœªåµæ¸¬">

    <label>å…¥åº«æ•¸é‡ (ä»¥ 10 ç‚ºå–®ä½):</label>
    <select id="editQty">
      <option value="10">10</option><option value="20">20</option>
      <option value="30">30</option><option value="40">40</option>
      <option value="50">50</option><option value="100">100</option>
    </select>

    <button class="btn-import" onclick="finalSubmit()">âœ… ç¢ºèªè³‡æ–™ï¼ŒåŒ¯å…¥åº«å­˜</button>
    <button onclick="location.reload()" style="background:#eee; color:#444; width:100%; margin-top:10px; font-size:14px; border:none; border-radius:10px; padding:12px; cursor:pointer;">ğŸ”„ é‡æ‹ä¸€å¼µ</button>
  </div>

  <div id="status" style="margin-top:10px; font-size:13px; color:#888;"></div>
  <canvas id="workCanvas"></canvas>
</div>

<!-- âœ… ZXing-wasm (IIFE) Reader -->
<script src="https://cdn.jsdelivr.net/npm/zxing-wasm@2.2.1/dist/iife/reader/index.js"></script>

<!-- âœ… Tesseract.js v7ï¼ˆOCR fallbackï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@7/dist/tesseract.min.js"></script>

<script>
  const video = document.getElementById('video');
  const preview = document.getElementById('photoPreview');
  const loader = document.getElementById('loader');
  const workCanvas = document.getElementById('workCanvas');
  const ctx = workCanvas.getContext('2d');
  let stream = null;

  function setStatus(msg) { document.getElementById('status').innerText = msg; }
  function setSourcePill(s) { document.getElementById('sourcePill').innerText = `SOURCE: ${s || "-"}`; }

  function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  function normalizeText(raw) {
    return (raw || "")
      .replace(/\s+/g, '')
      .replace(/[Il|]/g, '1')
      .replace(/O/g, '0');
  }

  // âœ… æˆåŠŸåˆ¤æ–·ï¼šä¸ä¾è³´æ‹¬è™Ÿï¼Œåªè¦æŠ“åˆ° 01+14ç¢¼ & 17+6ç¢¼ å°±ç®—æœ‰æ ¸å¿ƒè³‡æ–™
  function hasGS1Core(text) {
    const s = normalizeText(text);
    const has01 = /01(\d{14})/.test(s) || /\(01\)(\d{14})/.test(s);
    const has17 = /17(\d{6})/.test(s)  || /\(17\)(\d{6})/.test(s);
    return has01 && has17;
  }

  function extractGS1Data(text) {
    const s = normalizeText(text);

    const m01 = s.match(/\(01\)(\d{14})/) || s.match(/01(\d{14})/);
    const m17 = s.match(/\(17\)(\d{6})/) || s.match(/17(\d{6})/);

    const m21 = s.match(/\(21\)([A-Z0-9\-]+)/) || s.match(/21([A-Z0-9\-]+)/);
    const m10 = s.match(/\(10\)([A-Z0-9\-]+)/) || s.match(/10([A-Z0-9\-]+)/);

    return {
      gtin: m01 ? m01[1] : "",
      exp:  m17 ? m17[1] : "",
      lot:  (m21 && m21[1]) ? m21[1] : ((m10 && m10[1]) ? m10[1] : "")
    };
  }

  function drawBase64ToWorkCanvas(base64Img) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        workCanvas.width = img.width;
        workCanvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        resolve();
      };
      img.onerror = reject;
      img.src = base64Img;
    });
  }

  // ============================
  // Cropï¼šå¤§æ¡† + æ”¾å¤§ 2.6
  // ============================
  function getScanBoxRect() {
    const cw = workCanvas.width;
    const ch = workCanvas.height;

    const boxW = cw * 0.92;
    const boxH = ch * 0.22;

    const x = Math.max(0, Math.floor((cw - boxW) / 2));
    const y = Math.max(0, Math.floor((ch - boxH) / 2));

    return { x, y, w: Math.floor(boxW), h: Math.floor(boxH) };
  }

  function cropCanvas(rect, scale = 2.6) {
    const c = document.createElement("canvas");
    c.width = Math.max(10, Math.floor(rect.w * scale));
    c.height = Math.max(10, Math.floor(rect.h * scale));
    const cctx = c.getContext("2d");

    const sx = Math.max(0, Math.min(workCanvas.width - 1, rect.x));
    const sy = Math.max(0, Math.min(workCanvas.height - 1, rect.y));
    const sw = Math.max(1, Math.min(workCanvas.width - sx, rect.w));
    const sh = Math.max(1, Math.min(workCanvas.height - sy, rect.h));

    cctx.drawImage(workCanvas, sx, sy, sw, sh, 0, 0, c.width, c.height);
    return c;
  }

  function canvasToDataURL(canvas, quality = 0.95) {
    return canvas.toDataURL("image/jpeg", quality);
  }

  function enhanceForOcr(baseCanvas, contrast=1.6, threshold=170) {
    const c = document.createElement("canvas");
    c.width = baseCanvas.width;
    c.height = baseCanvas.height;
    const cctx = c.getContext("2d");
    cctx.drawImage(baseCanvas, 0, 0);

    const img = cctx.getImageData(0, 0, c.width, c.height);
    const d = img.data;

    for (let i=0; i<d.length; i+=4) {
      const r=d[i], g=d[i+1], b=d[i+2];
      let y = 0.299*r + 0.587*g + 0.114*b;
      y = (y - 128) * contrast + 128;
      y = Math.max(0, Math.min(255, y));
      const v = (y > threshold) ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
    cctx.putImageData(img, 0, 0);
    return c;
  }

  function tooSmallForOCR(w, h) {
    return (w < 60 || h < 24);
  }

  // ============================
  // ZXing-wasm
  // ============================
  function ensureZXingWasmLoaded() {
    if (!window.ZXingWASM || typeof window.ZXingWASM.readBarcodes !== "function") {
      throw new Error("zxing-wasm æœªè¼‰å…¥æˆåŠŸï¼šè«‹æª¢æŸ¥ Network æ˜¯å¦æœ‰ zxing-wasm iife index.js è¢«æ“‹æˆ– 404");
    }
  }

  let zxingPrepared = false;
  let zxingWasmUrl = "/zxing_reader.wasm"; // default self-host

  async function detectWasmUrl() {
    // å…ˆè©¦ self-hostï¼Œå¤±æ•—å†ç”¨ CDN
    const cdn = "https://cdn.jsdelivr.net/npm/zxing-wasm@2.2.1/dist/reader/zxing_reader.wasm";
    try {
      const r = await fetch("/zxing_reader.wasm", { method: "HEAD", cache: "no-store" });
      if (r.ok) return "/zxing_reader.wasm";
    } catch (_) {}
    return cdn;
  }

  async function prepareZXingReaderModuleOnce() {
    ensureZXingWasmLoaded();
    if (zxingPrepared) return;

    zxingWasmUrl = await detectWasmUrl();

    window.ZXingWASM.prepareZXingModule({
      overrides: {
        locateFile: (path, prefix) => {
          if (!path.endsWith(".wasm")) return prefix + path;
          return zxingWasmUrl;
        }
      },
      fireImmediately: true
    });

    zxingPrepared = true;
  }

  async function decodeBarcodeWithZXing(cropRawCanvas) {
    await prepareZXingReaderModuleOnce();
    const imgData = cropRawCanvas.getContext("2d").getImageData(0, 0, cropRawCanvas.width, cropRawCanvas.height);

    const results = await window.ZXingWASM.readBarcodes(imgData, {
      tryHarder: true,
      maxNumberOfSymbols: 1
    });

    if (!results || !results.length) return "";
    return results[0].text || "";
  }

  // ============================
  // Tesseract v7 worker
  // ============================
  async function ensureTesseractLoaded() {
    if (!window.Tesseract || typeof window.Tesseract.createWorker !== "function") {
      throw new Error("Tesseract.js v7 æœªè¼‰å…¥æˆåŠŸï¼šè«‹æª¢æŸ¥ Network æ˜¯å¦æœ‰ tesseract.min.js è¢«æ“‹æˆ– 404");
    }
  }

  let ocrWorker = null;
  async function getOcrWorker() {
    await ensureTesseractLoaded();
    if (ocrWorker) return ocrWorker;

    setStatus("ğŸ§  åˆå§‹åŒ– OCR å¼•æ“ (Tesseract v7 worker)...");
    ocrWorker = await Tesseract.createWorker("eng");
    return ocrWorker;
  }

  function rotateDataUrl(dataUrl, deg) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const rad = deg * Math.PI / 180;
        const c = document.createElement('canvas');
        const cctx = c.getContext('2d');

        const w = img.width, h = img.height;
        if (deg % 180 !== 0) { c.width = h; c.height = w; }
        else { c.width = w; c.height = h; }

        cctx.translate(c.width / 2, c.height / 2);
        cctx.rotate(rad);
        cctx.drawImage(img, -w / 2, -h / 2);

        resolve(c.toDataURL('image/jpeg', 0.95));
      };
      img.src = dataUrl;
    });
  }

  async function ocrBarcodeAutoRotateVerbose(dataUrl, tagForDebug) {
    const angles = [0, 90, 180, 270];
    const worker = await getOcrWorker();

    const options = {
      tessedit_char_whitelist: "0123456789()ABCDEFGHIJKLMNOPQRSTUVWXYZ-",
      tessedit_pageseg_mode: "7"
    };

    const attempts = [];
    for (const deg of angles) {
      setStatus(`ğŸ§¨ OCR æ—‹è½‰å¼·æ”»ï¼š${tagForDebug} ${deg}Â°...`);
      const targetUrl = (deg === 0) ? dataUrl : await rotateDataUrl(dataUrl, deg);

      const ret = await worker.recognize(targetUrl, options);
      const text = normalizeText((ret && ret.data && ret.data.text) ? ret.data.text : "");
      attempts.push({ deg, text });

      if (hasGS1Core(text)) {
        return { bestText: text, attempts, bestDeg: deg };
      }
    }
    return { bestText: attempts.length ? attempts[attempts.length - 1].text : "", attempts, bestDeg: null };
  }

  // ============================
  // FLOW A: å…ˆ ZXing-wasmï¼Œå† OCR fallbackï¼ˆrawâ†’enhï¼‰
  // ============================
  async function analyzeFromWorkCanvas() {
    loader.style.display = "block";

    if (workCanvas.width < 50 || workCanvas.height < 50) {
      throw new Error(`å½±åƒè¼‰å…¥å¤±æ•—æˆ–å°ºå¯¸éå°ï¼š${workCanvas.width}x${workCanvas.height}`);
    }

    const debugLines = [];
    debugLines.push(`WASM_URL: ${zxingWasmUrl || "(not set yet)"}`);

    const rect = getScanBoxRect();
    const cropRaw = cropCanvas(rect, 2.6);

    // 1) ZXing-wasmï¼ˆä¸æ—‹è½‰ï¼‰
    setStatus("ğŸ“¡ å…ˆå˜—è©¦è§£ç¢¼æ¢ç¢¼ï¼ˆzxing-wasmï¼Œä¸æ—‹è½‰ï¼‰...");
    let zxingText = "";
    try {
      zxingText = await decodeBarcodeWithZXing(cropRaw);
    } catch (e) {
      zxingText = "";
      debugLines.push(`[ZXING_WASM][ERROR] ${e && e.message ? e.message : String(e)}`);
    }
    debugLines.push(`[ZXING_WASM][RAW] ${zxingText || "(empty)"}`);

    let data = extractGS1Data(zxingText);
    debugLines.push(`[ZXING_WASM][PARSE] gtin=${data.gtin || "-"} exp=${data.exp || "-"} lot=${data.lot || "-"}`);

    if (data.gtin && data.exp) {
      return {
        data,
        source: "ZXING_WASM",
        raw: zxingText,
        debug_text: debugLines.join("\n")
      };
    }

    // 2) OCR fallbackï¼šraw crop å…ˆè·‘ï¼Œå†è·‘äºŒå€¼åŒ–
    setStatus("âš ï¸ æ¢ç¢¼è§£ç¢¼æœªå–å¾—å®Œæ•´ 01/17ï¼Œæ”¹ç”¨ OCR fallback...");
    if (tooSmallForOCR(cropRaw.width, cropRaw.height)) {
      setStatus("âš ï¸ åˆ‡åœ–å¤ªå°ï¼Œæ”¹ç”¨æ•´å¼µåœ– OCR fallback...");
      const fullUrl = workCanvas.toDataURL("image/jpeg", 0.92);
      const o = await ocrBarcodeAutoRotateVerbose(fullUrl, "FULL");
      debugLines.push(`[OCR_FULL][BEST_DEG] ${o.bestDeg === null ? "-" : o.bestDeg}`);
      for (const a of o.attempts) debugLines.push(`[OCR_FULL][${a.deg}] ${a.text || "(empty)"}`);

      data = extractGS1Data(o.bestText);
      debugLines.push(`[OCR_FULL][PARSE] gtin=${data.gtin || "-"} exp=${data.exp || "-"} lot=${data.lot || "-"}`);

      return { data, source: "OCR_FULL", raw: o.bestText, debug_text: debugLines.join("\n") };
    }

    // 2-1) raw crop OCR
    const rawUrl = canvasToDataURL(cropRaw, 0.95);
    const o1 = await ocrBarcodeAutoRotateVerbose(rawUrl, "CROP_RAW");
    debugLines.push(`[OCR_CROP_RAW][BEST_DEG] ${o1.bestDeg === null ? "-" : o1.bestDeg}`);
    for (const a of o1.attempts) debugLines.push(`[OCR_CROP_RAW][${a.deg}] ${a.text || "(empty)"}`);

    data = extractGS1Data(o1.bestText);
    debugLines.push(`[OCR_CROP_RAW][PARSE] gtin=${data.gtin || "-"} exp=${data.exp || "-"} lot=${data.lot || "-"}`);

    if (data.gtin && data.exp) {
      return { data, source: "OCR_CROP_RAW", raw: o1.bestText, debug_text: debugLines.join("\n") };
    }

    // 2-2) enhanced crop OCR
    const enhanced = enhanceForOcr(cropRaw, 1.6, 170);
    if (tooSmallForOCR(enhanced.width, enhanced.height)) {
      // enhanced å¤ªå°å°±ä¸è¦è·‘ï¼Œç›´æ¥å› raw çš„çµæœ
      return { data, source: "OCR_CROP_RAW", raw: o1.bestText, debug_text: debugLines.join("\n") };
    }

    const enhUrl = canvasToDataURL(enhanced, 0.95);
    const o2 = await ocrBarcodeAutoRotateVerbose(enhUrl, "CROP_ENH");
    debugLines.push(`[OCR_CROP_ENH][BEST_DEG] ${o2.bestDeg === null ? "-" : o2.bestDeg}`);
    for (const a of o2.attempts) debugLines.push(`[OCR_CROP_ENH][${a.deg}] ${a.text || "(empty)"}`);

    data = extractGS1Data(o2.bestText);
    debugLines.push(`[OCR_CROP_ENH][PARSE] gtin=${data.gtin || "-"} exp=${data.exp || "-"} lot=${data.lot || "-"}`);

    return { data, source: "OCR_CROP_ENH", raw: o2.bestText, debug_text: debugLines.join("\n") };
  }

  async function triggerAnalysisFromBase64(base64Img) {
    loader.style.display = 'block';
    setStatus("âŒ› æ­£åœ¨æº–å‚™åˆ†æ...");

    await drawBase64ToWorkCanvas(base64Img);

    const result = await analyzeFromWorkCanvas();
    const data = result.data;

    setSourcePill(result.source);

    // âœ… é¡¯ç¤ºã€Œå®Œæ•´ debugã€ï¼šZXing rawã€æ¯å€‹ OCR è§’åº¦çµæœã€parse çµæœ
    document.getElementById('rawAll').value =
      [
        `=== SOURCE: ${result.source} ===`,
        result.debug_text || "(no debug)",
      ].join("\n");

    // âœ… ä½ å¾Œå°ä¸å†éœ€è¦ product_codeï¼Œæ‰€ä»¥ä¸å†é¡¯ç¤º GTIN æ¬„ä½
    // é€™è£¡åªå¡«ä½ è¦é€çš„å…©å€‹æ¬„ä½ï¼šlot + expï¼ˆä»å¯äººå·¥ä¿®æ”¹ï¼‰
    document.getElementById('editLot').value =
      data.lot || normalizeText(result.raw).replace(/[^A-Za-z0-9]/g, '').substring(0,12);

    document.getElementById('editExp').value = data.exp;

    loader.style.display = 'none';
    document.getElementById('reviewArea').style.display = 'block';

    setStatus(
      (data.exp)
        ? `è¾¨è­˜å®Œæˆï¼ˆä¾†æºï¼š${result.source}ï¼‰ï¼Œè«‹è¤‡æ ¸è³‡æ–™ã€‚`
        : `âš ï¸ æœªæŠ“åˆ°æœ‰æ•ˆæ—¥æœŸ(17)ï¼Œå»ºè­°é‡æ‹æˆ–äººå·¥ä¿®æ­£ã€‚ï¼ˆä¾†æºï¼š${result.source}ï¼‰`
    );
  }

  // âœ… for <input type="file" onchange="handleFileUpload(event)">
  async function handleFileUpload(e) {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const base64 = await fileToBase64(file);

    preview.src = base64;
    prepareUIForAnalysis();

    try {
      await triggerAnalysisFromBase64(base64);
    } catch (err) {
      alert("è¾¨è­˜ç™¼ç”ŸéŒ¯èª¤: " + (err && err.message ? err.message : String(err)));
      location.reload();
    }
  }


  // ============================
  // Camera / UI
  // ============================
  async function startCamera() {
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment", width: { ideal: 1920 } }
      });
      video.srcObject = stream;

      document.getElementById('displayArea').style.display = 'block';
      document.getElementById('modeSelect').style.display = 'none';
      document.getElementById('btnSnap').style.display = 'block';

      setStatus("è«‹æŠŠæ¢ç¢¼ã€æ©«æ”¾ã€åœ¨ä¸­é–“ç´°é•·æ¡†å…§ï¼ˆé¿å…åå…‰ã€é è¿‘ä¸€é»ï¼‰ã€‚");
    } catch(e) {
      alert("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—ï¼Œè«‹ç¢ºèªæ¬Šé™");
    }
  }

  async function handleFileUpload(e) {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const base64 = await fileToBase64(file);

    preview.src = base64;
    prepareUIForAnalysis();

    try {
      await triggerAnalysisFromBase64(base64);
    } catch (err) {
      alert("è¾¨è­˜ç™¼ç”ŸéŒ¯èª¤: " + (err && err.message ? err.message : String(err)));
      location.reload();
    }
  }

  async function takeSnapshot() {
    if (!video.videoWidth || !video.videoHeight) {
      alert("ç›¸æ©Ÿå°šæœªå°±ç·’ï¼Œè«‹ç­‰ç•«é¢å‡ºç¾å¾Œå†æ‹ç…§");
      return;''''''
    }

    workCanvas.width = video.videoWidth;
    workCanvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, workCanvas.width, workCanvas.height);

    const base64 = workCanvas.toDataURL('image/jpeg', 0.92);

    preview.src = base64;
    prepareUIForAnalysis();

    try {
      await triggerAnalysisFromBase64(base64);
    } catch (err) {
      alert("è¾¨è­˜ç™¼ç”ŸéŒ¯èª¤: " + (err && err.message ? err.message : String(err)));
      location.reload();
    }
  }

  function prepareUIForAnalysis() {
    video.style.display = 'none';
    preview.style.display = 'block';
    document.getElementById('displayArea').style.display = 'block';
    document.getElementById('modeSelect').style.display = 'none';
    document.getElementById('btnSnap').style.display = 'none';
    document.getElementById('guidelines').style.display = 'none';
  }

  // ============================
  // Submit âœ… ä¾ä½ è¦æ±‚ï¼šå¾Œå°ä¸å†å‚³ product_code
  // ============================
  async function finalSubmit() {
    const qty = parseInt(document.getElementById('editQty').value, 10);
    const payload = {
      item_uuid: document.getElementById('editLot').value,
      expiry_date: document.getElementById('editExp').value,
      quantity: qty,
      from_loc: 'FACTORY', to_loc: 'MAIN', operator: 'MANUAL_REVIEW'
    };

    loader.style.display = 'block';
    const res = await fetch('/api/stock', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (res.ok) {
      alert("âœ… åŒ¯å…¥æˆåŠŸï¼å·²å­˜å…¥ " + qty + " ä»¶ç‰©æ–™ã€‚");
      location.href = 'index.html';
    } else {
      const err = await res.json().catch(() => ({message: "é€£ç·šç•°å¸¸"}));
      alert("âŒ å¤±æ•—: " + err.message);
      loader.style.display = 'none';
    }
  }
</script>
</body>
</html>
