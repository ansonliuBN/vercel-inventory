<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>æ¥­å‹™ç«¯ - æƒæå…¥åº«ï¼ˆæŒ‰éˆ•å•Ÿå‹•ï¼‰</title>

<style>
  body { font-family:-apple-system, sans-serif; padding:20px; background:#f4f4f9; color:#333; text-align:center; }
  .card { background:white; padding:20px; border-radius:15px; box-shadow:0 4px 15px rgba(0,0,0,0.1); }
  button { background:#7360f2; color:white; border:none; padding:16px; border-radius:10px; cursor:pointer; width:100%; font-size:16px; font-weight:bold; margin-top:10px; }
  .secondary { background:#444; }
  .back-btn { background:#666; }
  .muted { color:#888; font-size:13px; margin:8px 0 12px; }
  #status { margin-top:12px; font-size:14px; color:#444; word-break:break-all; min-height:56px; }
  .spinner { display:none; margin:10px auto; width:30px; height:30px; border:3px solid #f3f3f3; border-top:3px solid #7360f2; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

  .camera-wrap{
    position: relative;
    width: 100%;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #7360f2;
    background:#000;
    display:none; /* âœ… ä¸€é–‹å§‹ä¸é¡¯ç¤ºç›¸æ©Ÿç•«é¢ */
  }
  video{ width:100%; height:auto; display:block; }

  .overlay{ position:absolute; inset:0; pointer-events:none; }
  .scan-box{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:78%;
    height:42%;
    border:2px solid rgba(255,255,255,0.95);
    border-radius:14px;
    box-shadow:0 0 0 9999px rgba(0,0,0,0.35);
  }
  .corner{ position:absolute; width:22px; height:22px; border:3px solid #00ffb3; }
  .c1{left:-2px; top:-2px; border-right:none; border-bottom:none; border-radius:12px 0 0 0;}
  .c2{right:-2px; top:-2px; border-left:none; border-bottom:none; border-radius:0 12px 0 0;}
  .c3{left:-2px; bottom:-2px; border-right:none; border-top:none; border-radius:0 0 0 12px;}
  .c4{right:-2px; bottom:-2px; border-left:none; border-top:none; border-radius:0 0 12px 0;}
  .scan-line{
    position:absolute;
    left:6%;
    top:12%;
    width:88%;
    height:2px;
    background: linear-gradient(90deg, transparent, #00ffb3, transparent);
    filter: drop-shadow(0 0 4px rgba(0,255,179,0.8));
    animation: scanmove 1.4s ease-in-out infinite;
    opacity:0.95;
  }
  @keyframes scanmove{
    0%{ transform: translateY(0); }
    50%{ transform: translateY(calc(100% + 120px)); }
    100%{ transform: translateY(0); }
  }

  canvas#workCanvas { display:none; }
</style>
</head>

<body>
  <div class="card">
    <h2>ğŸ“· æƒæå…¥åº«ï¼ˆGS1-128 / QR / DataMatrixï¼‰</h2>
    <div class="muted">
      æŒ‰ã€Œé–‹å•Ÿç›¸æ©Ÿã€æ‰æœƒé–‹å§‹æƒæã€‚<br>
      å»ºè­°è·é›¢ 10â€“15cmã€é¿å…åå…‰ï¼›GS1-128 å´æ”¾ä¹Ÿæœƒè‡ªå‹•æ—‹è½‰å®¹éŒ¯ã€‚
    </div>

    <button id="btnStart">ğŸ“¸ é–‹å•Ÿç›¸æ©Ÿé–‹å§‹æƒæ</button>
    <button id="btnStop" class="secondary" disabled>â›” åœæ­¢æƒæ</button>

    <div class="camera-wrap" id="cameraWrap">
      <video id="video" autoplay muted playsinline></video>
      <div class="overlay">
        <div class="scan-box" id="scanBox">
          <div class="corner c1"></div>
          <div class="corner c2"></div>
          <div class="corner c3"></div>
          <div class="corner c4"></div>
          <div class="scan-line"></div>
        </div>
      </div>
    </div>

    <div class="spinner" id="spin"></div>
    <div id="status">å°šæœªå•Ÿå‹•</div>

    <button class="back-btn" onclick="location.href='index.html'">â¬…ï¸ å›åˆ°ç¸½è¡¨</button>

    <canvas id="workCanvas"></canvas>
  </div>

  <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>

  <script type="module">
    import { BrowserMultiFormatReader, DecodeHintType, BarcodeFormat } 
      from "https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.5/+esm";

    const video = document.getElementById('video');
    const statusEl = document.getElementById('status');
    const spin = document.getElementById('spin');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const cameraWrap = document.getElementById('cameraWrap');
    const scanBox = document.getElementById('scanBox');
    const workCanvas = document.getElementById('workCanvas');
    const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });

    const hints = new Map();
    hints.set(DecodeHintType.POSSIBLE_FORMATS, [
      BarcodeFormat.CODE_128,
      BarcodeFormat.QR_CODE,
      BarcodeFormat.DATA_MATRIX
    ]);
    hints.set(DecodeHintType.TRY_HARDER, true);

    const reader = new BrowserMultiFormatReader(hints, 600);

    let scanning = false;
    let lastSuccessAt = 0;
    let watchdogTimer = null;
    let rotateTryTimer = null;
    let ocrTimer = null;

    function setStatus(html){ statusEl.innerHTML = html; }
    function setBusy(b){ spin.style.display = b ? 'block' : 'none'; }

    function stopAllTimers(){
      if (watchdogTimer) clearInterval(watchdogTimer);
      if (rotateTryTimer) clearInterval(rotateTryTimer);
      if (ocrTimer) clearTimeout(ocrTimer);
      watchdogTimer = rotateTryTimer = ocrTimer = null;
    }

    function parseGS1(raw) {
      const s = String(raw || '').replace(/\s+/g, '').replace(/\((\d{2})\)/g, '$1');
      let i = 0;
      const out = {};
      const read = (n) => s.slice(i, i += n);

      while (i < s.length) {
        const ai = s.slice(i, i + 2);
        i += 2;

        if (ai === '01') out.gtin = read(14);
        else if (ai === '11') out.mfg = read(6);
        else if (ai === '17') out.exp = read(6);
        else if (ai === '21') { out.sn = s.slice(i); break; }
        else if (ai === '10') { out.lot = s.slice(i); break; }
        else break;
      }

      const tail = (out.sn || out.lot || '');
      const serial8 = tail.replace(/-.+$/, '').slice(0, 8).toUpperCase();
      out.key = (out.mfg && out.exp && serial8) ? `${out.mfg}_${out.exp}_${serial8}` : '';
      return out;
    }

    function getScanRectOnVideo(){
      const wrapRect = cameraWrap.getBoundingClientRect();
      const boxRect = scanBox.getBoundingClientRect();
      return {
        x: (boxRect.left - wrapRect.left) / wrapRect.width,
        y: (boxRect.top - wrapRect.top) / wrapRect.height,
        w: boxRect.width / wrapRect.width,
        h: boxRect.height / wrapRect.height
      };
    }

    function captureROIToCanvas(rotationDeg = 0){
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      if (!vw || !vh) return false;

      const roi = getScanRectOnVideo();
      const sx = Math.max(0, Math.floor(roi.x * vw));
      const sy = Math.max(0, Math.floor(roi.y * vh));
      const sw = Math.min(vw - sx, Math.floor(roi.w * vw));
      const sh = Math.min(vh - sy, Math.floor(roi.h * vh));

      const rot = ((rotationDeg % 360) + 360) % 360;
      const outW = (rot === 90 || rot === 270) ? sh : sw;
      const outH = (rot === 90 || rot === 270) ? sw : sh;

      workCanvas.width = outW;
      workCanvas.height = outH;

      workCtx.save();
      workCtx.clearRect(0,0,outW,outH);

      if (rot === 0){
        workCtx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
      } else {
        workCtx.translate(outW/2, outH/2);
        workCtx.rotate(rot * Math.PI / 180);
        workCtx.drawImage(video, sx, sy, sw, sh, -sw/2, -sh/2, sw, sh);
      }

      workCtx.restore();
      return true;
    }

    async function tryDecodeFromCanvasOnce(){
      const rotations = [0, 90, 180, 270];
      for (const rot of rotations){
        const ok = captureROIToCanvas(rot);
        if (!ok) continue;

        const url = workCanvas.toDataURL('image/png', 1.0);
        try{
          const res = await reader.decodeFromImageUrl(url);
          return { text: res.getText(), rot };
        }catch(e){}
      }
      return null;
    }

    async function ocrFallbackFromCanvas(){
      // OCR èµ° 0 åº¦ ROIï¼ˆä½ è¦æ›´ç‹ å¯ä»¥æ”¹æˆ 4 è§’åº¦éƒ½è·‘ä¸€æ¬¡ OCRï¼‰
      captureROIToCanvas(0);

      // grayscale + contrast
      const imgData = workCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        let v = (r*0.299 + g*0.587 + b*0.114);
        v = (v - 128) * 2.8 + 128;
        v = Math.max(0, Math.min(255, v));
        data[i] = data[i+1] = data[i+2] = v;
      }
      workCtx.putImageData(imgData, 0, 0);

      const url = workCanvas.toDataURL('image/jpeg', 0.92);
      const res = await Tesseract.recognize(url, 'eng', {
        logger: m => {
          if (m.status === 'recognizing text') {
            setStatus(`ğŸ§  OCR è¾¨è­˜ä¸­: ${Math.round(m.progress * 100)}%`);
          }
        }
      });

      let clean = (res.data.text || '')
        .replace(/\s+/g, '')
        .replace(/[\[\{]/g, '(')
        .replace(/[\]\}]/g, ')')
        .replace(/O/g, '0')
        .replace(/[Il|]/g, '1')
        .replace(/S/g, '5')
        .replace(/B/g, '8');

      return clean;
    }

    async function postToBackend({ rawText, formatNote }){
      const gs1 = parseGS1(rawText);
      const payload = {
        item_uuid: gs1.key || rawText,
        product_code: gs1.gtin || null,
        expiry_date: gs1.exp || null,
        from_loc: 'FACTORY',
        to_loc: 'MAIN',
        operator: formatNote || 'SCAN'
      };

      await fetch('/api/stock', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });

      return { gs1, payload };
    }

    async function startScan(){
      stopAllTimers();
      setBusy(true);
      setStatus('ğŸ¥ å•Ÿå‹•ç›¸æ©Ÿä¸­â€¦');
      scanning = true;
      btnStart.disabled = true;
      btnStop.disabled = false;
      cameraWrap.style.display = 'block';

      try{
        await reader.decodeFromVideoDevice(
          null,
          video,
          async (result, err) => {
            if (!scanning) return;

            if (result) {
              const text = result.getText();
              lastSuccessAt = Date.now();

              setBusy(true);
              setStatus(`âœ… å·²æƒåˆ°è³‡æ–™ï¼Œè™•ç†ä¸­â€¦<br>${text}`);

              try{
                const out = await postToBackend({ rawText: text, formatNote: 'LIVE_SCAN' });

                reader.reset();
                scanning = false;
                stopAllTimers();
                setBusy(false);
                btnStart.disabled = false;
                btnStop.disabled = true;

                setStatus(
                  `<b style="color:green">âœ… å…¥åº«æˆåŠŸ</b><br>` +
                  `Raw: ${text}<br>` +
                  `${out.gs1.gtin ? `GTIN(01): ${out.gs1.gtin}<br>` : ''}` +
                  `${out.gs1.mfg ? `MFG(11): ${out.gs1.mfg}<br>` : ''}` +
                  `${out.gs1.exp ? `EXP(17): ${out.gs1.exp}<br>` : ''}` +
                  `${(out.gs1.lot||out.gs1.sn) ? `TAIL(10/21): ${(out.gs1.lot||out.gs1.sn)}<br>` : ''}` +
                  `${out.gs1.key ? `KEY: ${out.gs1.key}` : ''}`
                );

                alert('âœ… å·²å…¥åº«ï¼');

              } catch(e){
                setBusy(false);
                setStatus(`<b style="color:red">âŒ é€å‡ºå…¥åº«å¤±æ•—</b><br>${String(e?.message||e)}`);
              }
            }
          }
        );
      } catch(e){
        setBusy(false);
        scanning = false;
        btnStart.disabled = false;
        btnStop.disabled = true;
        setStatus(`<b style="color:red">âŒ ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—</b><br>è«‹ç¢ºèª https/localhost ä¸¦å…è¨±ç›¸æ©Ÿæ¬Šé™ã€‚`);
        return;
      }

      lastSuccessAt = Date.now();
      setBusy(false);
      setStatus('âœ… ç›¸æ©Ÿå·²å•Ÿå‹•ï¼Œè«‹æŠŠæ¢ç¢¼æ”¾å…¥æ¡†å…§');

      // Watchdogï¼š4 ç§’æ²’æˆåŠŸ â†’ æ—‹è½‰å®¹éŒ¯ï¼›10 ç§’å¾Œ OCR fallback
      watchdogTimer = setInterval(() => {
        if (!scanning) return;

        const now = Date.now();
        const since = now - lastSuccessAt;

        if (since > 4000 && !rotateTryTimer){
          setStatus('ğŸ§­ å³æ™‚æƒæå°šæœªæˆåŠŸï¼Œå•Ÿå‹•æ—‹è½‰å®¹éŒ¯è§£ç¢¼â€¦ï¼ˆè«‹ä¿æŒç©©å®šï¼‰');

          rotateTryTimer = setInterval(async () => {
            if (!scanning) return;

            try{
              const found = await tryDecodeFromCanvasOnce();
              if (found?.text){
                lastSuccessAt = Date.now();
                setStatus(`âœ… æ—‹è½‰å®¹éŒ¯è§£ç¢¼æˆåŠŸï¼ˆrot=${found.rot}Â°ï¼‰<br>${found.text}`);

                const out = await postToBackend({ rawText: found.text, formatNote: `ROTATE_${found.rot}` });

                reader.reset();
                scanning = false;
                stopAllTimers();
                setBusy(false);
                btnStart.disabled = false;
                btnStop.disabled = true;

                setStatus(
                  `<b style="color:green">âœ… å…¥åº«æˆåŠŸ</b><br>` +
                  `Raw: ${found.text}<br>` +
                  `${out.gs1.gtin ? `GTIN(01): ${out.gs1.gtin}<br>` : ''}` +
                  `${out.gs1.mfg ? `MFG(11): ${out.gs1.mfg}<br>` : ''}` +
                  `${out.gs1.exp ? `EXP(17): ${out.gs1.exp}<br>` : ''}` +
                  `${(out.gs1.lot||out.gs1.sn) ? `TAIL(10/21): ${(out.gs1.lot||out.gs1.sn)}<br>` : ''}` +
                  `${out.gs1.key ? `KEY: ${out.gs1.key}` : ''}`
                );

                alert('âœ… å·²å…¥åº«ï¼');
              }
            }catch(_){}
          }, 1200);

          ocrTimer = setTimeout(async () => {
            if (!scanning) return;

            setBusy(true);
            setStatus('ğŸ§  ä»æœªæˆåŠŸï¼Œå•Ÿå‹• OCR fallbackï¼ˆè®€äººçœ¼å­—ä¸²ï¼‰â€¦');

            try{
              const ocrText = await ocrFallbackFromCanvas();
              setStatus(`<b>OCR è®€åˆ°ï¼š</b><br>${ocrText}`);

              const gs1 = parseGS1(ocrText);
              if (!gs1.key && !gs1.gtin && !gs1.exp) {
                setBusy(false);
                setStatus(`<b style="color:red">âŒ OCR ä»ç„¡æ³•è§£æ</b><br>è«‹æ›´è¿‘ã€è£œå…‰ã€é¿å…åå…‰ï¼Œæˆ–æŠŠæ¢ç¢¼æ©«æ”¾ã€‚<br>OCR: ${ocrText}`);
                return;
              }

              const out = await postToBackend({ rawText: ocrText, formatNote: 'OCR_FALLBACK' });

              reader.reset();
              scanning = false;
              stopAllTimers();
              setBusy(false);
              btnStart.disabled = false;
              btnStop.disabled = true;

              setStatus(
                `<b style="color:green">âœ… OCR å…¥åº«æˆåŠŸ</b><br>` +
                `OCR: ${ocrText}<br>` +
                `${out.gs1.gtin ? `GTIN(01): ${out.gs1.gtin}<br>` : ''}` +
                `${out.gs1.mfg ? `MFG(11): ${out.gs1.mfg}<br>` : ''}` +
                `${out.gs1.exp ? `EXP(17): ${out.gs1.exp}<br>` : ''}` +
                `${(out.gs1.lot||out.gs1.sn) ? `TAIL(10/21): ${(out.gs1.lot||out.gs1.sn)}<br>` : ''}` +
                `${out.gs1.key ? `KEY: ${out.gs1.key}` : ''}`
              );

              alert('âœ… å·²å…¥åº«ï¼ˆOCR fallbackï¼‰ï¼');

            } catch(e){
              setBusy(false);
              setStatus(`<b style="color:red">âŒ OCR fallback å‡ºéŒ¯</b><br>${String(e?.message||e)}`);
            }
          }, 10000);
        }
      }, 800);
    }

    function stopScan(){
      scanning = false;
      stopAllTimers();
      try { reader.reset(); } catch(_){}
      setBusy(false);
      btnStart.disabled = false;
      btnStop.disabled = true;
      setStatus('â›” å·²åœæ­¢ã€‚æŒ‰ã€Œé–‹å•Ÿç›¸æ©Ÿé–‹å§‹æƒæã€å†å•Ÿå‹•ã€‚');

      // å¯é¸ï¼šåœæ­¢å¾Œéš±è—ç•«é¢
      cameraWrap.style.display = 'none';

      // åœæ­¢ç›¸æ©Ÿä¸²æµï¼ˆé‡‹æ”¾é¡é ­ï¼‰
      const stream = video.srcObject;
      if (stream && stream.getTracks) {
        stream.getTracks().forEach(t => t.stop());
      }
      video.srcObject = null;
    }

    btnStart.onclick = startScan;
    btnStop.onclick = stopScan;
  </script>

</body>
</html>
