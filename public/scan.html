<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>æ¥­å‹™ç«¯ - æ™ºèƒ½è‡ªå‹•å…¥åº«ç³»çµ±</title>
  <style>
    body { font-family:-apple-system, sans-serif; padding:20px; background:#f4f4f9; color:#333; text-align:center; }
    .card { background:white; padding:20px; border-radius:15px; box-shadow:0 4px 15px rgba(0,0,0,0.1); }
    button { background:#7360f2; color:white; border:none; padding:16px; border-radius:10px; cursor:pointer; width:100%; font-size:16px; font-weight:bold; margin-top:10px; }
    .secondary { background:#444; }
    .back-btn { background:#666; margin-top: 15px; }
    #status { margin-top:12px; font-size:14px; color:#444; word-break:break-all; min-height:80px; line-height: 1.5; }
    .spinner { display:none; margin:10px auto; width:30px; height:30px; border:3px solid #f3f3f3; border-top:3px solid #7360f2; border-radius:50%; animation:spin 1s linear infinite; }
    @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
    .camera-wrap { position: relative; width: 100%; border-radius: 12px; overflow: hidden; border: 2px solid #7360f2; background:#000; display:none; margin-top: 10px; }
    video { width:100%; height:auto; display:block; }
    .scan-box { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:90%; height:30%; border:2px solid #00ffb3; border-radius:14px; box-shadow:0 0 0 9999px rgba(0,0,0,0.4); }
    canvas#workCanvas { display:none; }
  </style>
</head>

<body>
  <div class="card">
    <h2>ğŸ“· æ™ºèƒ½è¾¨è­˜å…¥åº«</h2>
    <p style="font-size: 13px; color: #666;">ç³»çµ±å°‡è‡ªå‹•åˆ‡æ›æƒæèˆ‡ OCR è¾¨è­˜</p>

    <button id="btnStart" onclick="window.__startScan()">ğŸ“¸ é–‹å•Ÿç›¸æ©Ÿ</button>
    <button id="btnStop" class="secondary" onclick="window.__stopScan()" disabled>â›” åœæ­¢</button>

    <div class="camera-wrap" id="cameraWrap">
      <video id="video" autoplay muted playsinline></video>
      <div class="scan-box"></div>
    </div>

    <div class="spinner" id="spin"></div>
    <div id="status">å°šæœªå•Ÿå‹•</div>

    <button class="back-btn" onclick="location.href='index.html'">â¬…ï¸ å›åˆ°ç¸½è¡¨</button>
    <canvas id="workCanvas"></canvas>
  </div>

  <script src="https://unpkg.com/@zxing/library@latest"></script>
  <script src="https://unpkg.com/@zxing/browser@latest"></script>
  <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>

  <script>
    const video = document.getElementById('video');
    const statusEl = document.getElementById('status');
    const spin = document.getElementById('spin');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const cameraWrap = document.getElementById('cameraWrap');
    const workCanvas = document.getElementById('workCanvas');
    const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });

    let stream = null, scanning = false, reader = null, controls = null;
    let lastSeenAt = 0, watchdogTimer = null;

    function setStatus(h){ statusEl.innerHTML = h; }
    function setBusy(b){ spin.style.display = b ? 'block' : 'none'; }

    function parseGS1(raw) {
      let s = String(raw || '').replace(/\s+/g, '');
      const out = {};
      
      // å¦‚æœæœ‰æ¨™æº– GS1 æ‹¬è™Ÿæ ¼å¼
      const matches = s.matchAll(/\((\d{2})\)([^()]+)/g);
      let foundAny = false;
      for (const m of matches) {
        foundAny = true;
        const ai = m[1], val = m[2];
        if (ai === '01') out.gtin = val;
        if (ai === '17') out.exp = val;
        if (ai === '21') out.sn = val;
      }

      // å¦‚æœå®Œå…¨æ²’æŠ“åˆ°æ‹¬è™Ÿï¼ˆç´” OCR æƒ…æ³ï¼‰ï¼Œæˆ‘å€‘æš´åŠ›çŒœæ¸¬
      if (!foundAny) {
          // è©¦è‘—æŠ“å‡ºåƒæ—¥æœŸ 250821 çš„éƒ¨åˆ† (6ä½æ•¸å­—)
          const dateMatch = s.match(/\d{6}/);
          if (dateMatch) out.exp = dateMatch[0];
          out.sn = s; // å‰©ä¸‹çš„å°±ç•¶åºè™Ÿ
      }

      out.uuid = (out.sn || s).substring(0, 12);
      return out;
    }

    async function postToBackend(text, method) {
      const gs1 = parseGS1(text);
      const payload = {
        item_uuid: gs1.uuid,
        product_code: gs1.gtin || null,
        expiry_date: gs1.exp || null,
        from_loc: 'FACTORY',
        to_loc: 'MAIN',
        operator: `AUTO_${method}`
      };
      await fetch('/api/stock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
    }

    function captureROI(rot = 0) {
      const vw = video.videoWidth, vh = video.videoHeight;
      if (!vw || !vh) return false;
      const sw = vw * 0.9, sh = vh * 0.3;
      const sx = (vw - sw) / 2, sy = (vh - sh) / 2;
      const outW = (rot === 90 || rot === 270) ? sh : sw;
      const outH = (rot === 90 || rot === 270) ? sw : sh;
      workCanvas.width = outW; workCanvas.height = outH;
      workCtx.save();
      if (rot !== 0) {
        workCtx.translate(outW/2, outH/2);
        workCtx.rotate(rot * Math.PI / 180);
        workCtx.drawImage(video, sx, sy, sw, sh, -sw/2, -sh/2, sw, sh);
      } else {
        workCtx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
      }
      workCtx.restore();
      return true;
    }

    async function autoOCR() {
      if (!scanning) return;
      captureROI(0);
      const url = workCanvas.toDataURL('image/jpeg', 0.9);
      setStatus('ğŸ§  è‡ªå‹•å•Ÿå‹•æ–‡å­—è¾¨è­˜ä¸­ (OCR)...');
      try {
        const res = await Tesseract.recognize(url, 'eng');
        let cleanText = res.data.text.replace(/\s+/g, '').replace(/[Il|]/g, '1').replace(/O/g, '0');
        if (cleanText.length > 5) {
          await postToBackend(cleanText, 'OCR');
          finish(cleanText, 'OCR');
        }
      } catch (e) { console.error(e); }
    }

    // --- ä¿®æ”¹å¾Œçš„å®Œæˆé‚è¼¯ï¼šå¢åŠ ç¢ºèªæ­¥é©Ÿ ---
    async function finish(text, method) {
      scanning = false;
      stopEverything();

      const gs1 = parseGS1(text);
      
      // é¡¯ç¤ºè¨ºæ–·è³‡è¨Šï¼Œå¹«ä½ æŠ“å‡ºç‚ºä»€éº¼æ˜¯ ES001
      const diagnosis = `
        <div style="text-align:left; background:#fff3cd; padding:15px; border-radius:10px; margin:10px 0; border:1px solid #ffeeba;">
          <b>ğŸ› ï¸ è¾¨è­˜è¨ºæ–·å ±å‘Šï¼š</b><br>
          è¾¨è­˜æ¨¡å¼ï¼š<span style="color:blue">${method}</span><br>
          åŸå§‹æŠ“å–æ–‡å­—ï¼š<code style="background:#eee;">${text}</code><br><br>
          <b>ğŸ“¦ é è¨ˆå­˜å…¥è³‡æ–™ï¼š</b><br>
          UUID (å‰12ç¢¼)ï¼š<b style="color:green">${gs1.uuid}</b><br>
          æœ‰æ•ˆæ—¥æœŸï¼š${gs1.exp || 'ç„¡'}<br>
          ç”¢å“ä»£ç¢¼ï¼š${gs1.gtin || 'ç„¡'}
        </div>
      `;
      
      setStatus(`<h3>ğŸ” è«‹ç¢ºèªè¾¨è­˜çµæœ</h3>${diagnosis}`);

      // æª¢æŸ¥ UUID æ˜¯å¦åˆç†ï¼ˆä¾‹å¦‚å¤ªçŸ­å¯èƒ½æ˜¯è®€éŒ¯äº†ï¼‰
      if (gs1.uuid.length < 5) {
          alert("è­¦å‘Šï¼šè¾¨è­˜å‡ºçš„åºè™Ÿå¤ªçŸ­ (" + gs1.uuid + ")ï¼Œå¯èƒ½æ˜¯è®€åˆ°é›œè¨Šã€‚è«‹é»æ“Šå–æ¶ˆä¸¦é‡æ‹ã€‚");
      }

      if (confirm(`ç¢ºèªè¦å°‡åºè™Ÿ [${gs1.uuid}] å­˜å…¥è³‡æ–™åº«å—ï¼Ÿ`)) {
        setBusy(true);
        setStatus('ğŸš€ æ­£åœ¨å˜—è©¦é€£ç·š API å¯«å…¥è³‡æ–™åº«...');
        
        try {
          const res = await fetch('/api/stock', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                item_uuid: gs1.uuid,
                product_code: gs1.gtin || null,
                expiry_date: gs1.exp || null,
                from_loc: 'FACTORY',
                to_loc: 'MAIN',
                operator: `AUTO_${method}`
            })
          });

          const result = await res.json();

          if (res.ok) {
            alert('âœ… å…¥åº«æˆåŠŸï¼');
            location.href = 'index.html';
          } else {
            // é€™è£¡æœ€é‡è¦ï¼å¦‚æœè³‡æ–™åº«å ±éŒ¯ï¼Œæœƒç›´æ¥é¡¯ç¤ºåœ¨é€™è£¡
            throw new Error(result.message || result.error || JSON.stringify(result));
          }
        } catch (e) {
          setBusy(false);
          setStatus(`<b style="color:red">âŒ API å¯«å…¥å¤±æ•—</b><br>åŸå› ï¼š${e.message}<br><br>è«‹æª¢æŸ¥ API Key æ˜¯å¦æ­£ç¢ºæˆ–è³‡æ–™è¡¨æ¬„ä½æ˜¯å¦åŒ¹é…ã€‚`);
          console.error("API Error:", e);
        }
      } else {
        setStatus('å·²å–æ¶ˆã€‚è«‹æŒ‰ã€Œé–‹å•Ÿç›¸æ©Ÿã€é‡æ–°å˜—è©¦ã€‚');
        btnStart.disabled = false;
      }
    }

    function stopEverything() {
      scanning = false; clearInterval(watchdogTimer);
      if (controls) controls.stop();
      if (stream) stream.getTracks().forEach(t => t.stop());
      video.srcObject = null; cameraWrap.style.display = 'none';
      btnStart.disabled = false; btnStop.disabled = true;
      setBusy(false);
    }

    window.__startScan = async function() {
      btnStart.disabled = true; btnStop.disabled = false;
      setStatus('ğŸ¥ æ­£åœ¨å•Ÿå‹•ç›¸æ©Ÿ...');
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        video.srcObject = stream;
        cameraWrap.style.display = 'block';
        scanning = true; lastSeenAt = Date.now();
        setBusy(false);

        // --- ä¿®æ­£éçš„ ZXing åˆå§‹åŒ– ---
        const ZX = window.ZXingBrowser || window.ZXing;
        if (!ZX) throw new Error("å¥—ä»¶è¼‰å…¥å¤±æ•—");

        const hints = new Map();
        // ç¢ºä¿ä½¿ç”¨æ­£ç¢ºçš„ç‰©ä»¶è·¯å¾‘
        const DecodeHintType = ZX.DecodeHintType || window.ZXing.DecodeHintType;
        if (DecodeHintType) {
            hints.set(DecodeHintType.TRY_HARDER, true);
        }
        
        reader = new ZX.BrowserMultiFormatReader(hints);
        
        controls = await reader.decodeFromVideoDevice(null, video, async (res) => {
          if (res && scanning) {
            await postToBackend(res.getText(), 'ZXING');
            finish(res.getText(), 'ZXING');
          }
        });

        watchdogTimer = setInterval(async () => {
          if (!scanning) return;
          const idleTime = Date.now() - lastSeenAt;
          if (idleTime > 4000) {
            const rots = [90, 270];
            for (let r of rots) {
              captureROI(r);
              try {
                const rs = await reader.decodeFromCanvas(workCanvas);
                if (rs && scanning) finish(rs.getText(), 'ROTATE');
              } catch(e){}
            }
          }
          if (idleTime > 10000) {
            autoOCR();
            lastSeenAt = Date.now();
          }
        }, 2000);

      } catch (e) {
        setStatus(`<b style="color:red">âŒ éŒ¯èª¤:</b> ${e.message}`);
        stopEverything();
      }
    };

    window.__stopScan = stopEverything;
  </script>
</body>
</html>