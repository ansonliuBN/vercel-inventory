<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>æ¥­å‹™ç«¯ - æƒæå…¥åº«ï¼ˆGS1/QR/DataMatrix + æ—‹è½‰ + OCRï¼‰</title>

<style>
  body { font-family:-apple-system, sans-serif; padding:20px; background:#f4f4f9; color:#333; text-align:center; }
  .card { background:white; padding:20px; border-radius:15px; box-shadow:0 4px 15px rgba(0,0,0,0.1); }
  button { background:#7360f2; color:white; border:none; padding:16px; border-radius:10px; cursor:pointer; width:100%; font-size:16px; font-weight:bold; margin-top:10px; }
  .secondary { background:#444; }
  .back-btn { background:#666; }
  .muted { color:#888; font-size:13px; margin:8px 0 12px; line-height:1.4; }
  #status { margin-top:12px; font-size:14px; color:#444; word-break:break-all; min-height:78px; }
  .spinner { display:none; margin:10px auto; width:30px; height:30px; border:3px solid #f3f3f3; border-top:3px solid #7360f2; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

  .camera-wrap{
    position: relative;
    width: 100%;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #7360f2;
    background:#000;
    display:none;
  }
  video{ width:100%; height:auto; display:block; }

  .overlay{ position:absolute; inset:0; pointer-events:none; }
  .scan-box{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:80%;
    height:40%;
    border:2px solid rgba(255,255,255,0.95);
    border-radius:14px;
    box-shadow:0 0 0 9999px rgba(0,0,0,0.35);
  }
  .corner{ position:absolute; width:22px; height:22px; border:3px solid #00ffb3; }
  .c1{left:-2px; top:-2px; border-right:none; border-bottom:none; border-radius:12px 0 0 0;}
  .c2{right:-2px; top:-2px; border-left:none; border-bottom:none; border-radius:0 12px 0 0;}
  .c3{left:-2px; bottom:-2px; border-right:none; border-top:none; border-radius:0 0 0 12px;}
  .c4{right:-2px; bottom:-2px; border-left:none; border-top:none; border-radius:0 0 12px 0;}
  .scan-line{
    position:absolute;
    left:6%;
    top:12%;
    width:88%;
    height:2px;
    background: linear-gradient(90deg, transparent, #00ffb3, transparent);
    filter: drop-shadow(0 0 4px rgba(0,255,179,0.8));
    animation: scanmove 1.4s ease-in-out infinite;
    opacity:0.95;
  }
  @keyframes scanmove{
    0%{ transform: translateY(0); }
    50%{ transform: translateY(calc(100% + 120px)); }
    100%{ transform: translateY(0); }
  }

  canvas#workCanvas { display:none; }
</style>
</head>

<body>
  <div class="card">
    <h2>ğŸ“· æƒæå…¥åº«ï¼ˆGS1-128 / QR / DataMatrixï¼‰</h2>
    <div class="muted">
      1) æŒ‰ã€Œé–‹å•Ÿç›¸æ©Ÿã€æ‰é–‹å§‹<br>
      2) å»ºè­°è·é›¢ 10â€“15cmã€é¿å…åå…‰<br>
      3) GS1-128 å´æ”¾æœƒè‡ªå‹•æ—‹è½‰å®¹éŒ¯ï¼›æƒä¸åˆ°æœƒè‡ªå‹• OCR
    </div>

    <button id="btnStart" onclick="window.__startScan()">ğŸ“¸ é–‹å•Ÿç›¸æ©Ÿé–‹å§‹æƒæ</button>
    <button id="btnStop" class="secondary" onclick="window.__stopScan()" disabled>â›” åœæ­¢</button>

    <div class="camera-wrap" id="cameraWrap">
      <video id="video" autoplay muted playsinline></video>
      <div class="overlay">
        <div class="scan-box" id="scanBox">
          <div class="corner c1"></div><div class="corner c2"></div>
          <div class="corner c3"></div><div class="corner c4"></div>
          <div class="scan-line"></div>
        </div>
      </div>
    </div>

    <div class="spinner" id="spin"></div>
    <div id="status">å°šæœªå•Ÿå‹•</div>

    <button class="back-btn" onclick="location.href='index.html'">â¬…ï¸ å›åˆ°ç¸½è¡¨</button>

    <canvas id="workCanvas"></canvas>
  </div>

  <!-- æœ¬åœ° ZXing -->
  //<script src="/libs/zxing/zxing-browser.min.js"></script>
  <script src="https://unpkg.com/@zxing/browser@latest"></script>

  <!-- OCRï¼ˆè‹¥ä½ ä¹‹å¾Œä¹Ÿè¢«æ“‹ï¼Œæˆ‘å†å¹«ä½ æœ¬åœ°åŒ–ï¼‰ -->
  <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>

  <script>
    // ---------- DOM ----------
    const video = document.getElementById('video');
    const statusEl = document.getElementById('status');
    const spin = document.getElementById('spin');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const cameraWrap = document.getElementById('cameraWrap');
    const scanBox = document.getElementById('scanBox');
    const workCanvas = document.getElementById('workCanvas');
    const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });

    // ---------- state ----------
    let stream = null;
    let scanning = false;
    let controls = null;
    let reader = null;

    let lastSeenAt = 0;
    let watchdogTimer = null;
    let rotateTryTimer = null;
    let ocrTimer = null;

    function setStatus(html){ statusEl.innerHTML = html; }
    function setBusy(b){ spin.style.display = b ? 'block' : 'none'; }

    // ä»»ä½• JS éŒ¯èª¤é¡¯ç¤ºåˆ°ç•«é¢
    window.onerror = function(message, source, lineno, colno) {
      setBusy(false);
      setStatus(`<b style="color:red">âŒ JS Error</b><br>${message}<br><small>${source}:${lineno}:${colno}</small>`);
    };

    // âœ… ä¸€è¼‰å…¥å°±é¡¯ç¤ºï¼ˆç¢ºä¿ JS æœ‰è·‘ï¼‰
    setStatus('âœ… JS å·²è¼‰å…¥ï¼Œè«‹æŒ‰ã€Œé–‹å•Ÿç›¸æ©Ÿã€');

    // ---------- helpers ----------
    function withTimeout(promise, ms, label){
      return new Promise((resolve, reject) => {
        const t = setTimeout(() => reject(new Error(`${label} timeout (${ms}ms)`)), ms);
        promise.then(v => { clearTimeout(t); resolve(v); })
               .catch(e => { clearTimeout(t); reject(e); });
      });
    }

    function stopAllTimers(){
      if (watchdogTimer) clearInterval(watchdogTimer);
      if (rotateTryTimer) clearInterval(rotateTryTimer);
      if (ocrTimer) clearTimeout(ocrTimer);
      watchdogTimer = rotateTryTimer = ocrTimer = null;
    }

    function closeCamera(){
      try{
        const s = video.srcObject || stream;
        if (s && s.getTracks) s.getTracks().forEach(t => t.stop());
      }catch(_){}
      stream = null;
      video.srcObject = null;
      cameraWrap.style.display = 'none';
    }

    function stopEverything(){
      scanning = false;
      stopAllTimers();
      setBusy(false);

      try{ if (controls && controls.stop) controls.stop(); }catch(_){}
      controls = null;

      try{ if (reader && reader.reset) reader.reset(); }catch(_){}
      reader = null;

      closeCamera();

      btnStart.disabled = false;
      btnStop.disabled = true;
    }

    async function waitVideoReady(ms=2500){
      // ç­‰ metadata or canplay
      if (video.readyState >= 2 && video.videoWidth > 0) return;

      await withTimeout(new Promise((resolve) => {
        const onReady = () => {
          cleanup();
          resolve();
        };
        const cleanup = () => {
          video.removeEventListener('loadedmetadata', onReady);
          video.removeEventListener('canplay', onReady);
        };
        video.addEventListener('loadedmetadata', onReady);
        video.addEventListener('canplay', onReady);
      }), ms, 'waitVideoReady');
    }

    // ---------- GS1 parser ----------
    function parseGS1(raw) {
      const s = String(raw || '')
        .replace(/\s+/g, '')
        .replace(/[\[\{]/g, '(').replace(/[\]\}]/g, ')')
        .replace(/\((\d{2})\)/g, '$1');

      let i = 0;
      const out = {};
      const read = (n) => s.slice(i, i += n);

      while (i < s.length) {
        const ai = s.slice(i, i + 2); i += 2;
        if (ai === '01') out.gtin = read(14);
        else if (ai === '11') out.mfg = read(6);
        else if (ai === '17') out.exp = read(6);
        else if (ai === '21') { out.sn = s.slice(i); break; }
        else if (ai === '10') { out.lot = s.slice(i); break; }
        else break;
      }

      const tail = (out.sn || out.lot || '');
      const serial8 = tail.replace(/-.+$/, '').slice(0, 8).toUpperCase();
      out.key = (out.mfg && out.exp && serial8) ? `${out.mfg}_${out.exp}_${serial8}` : '';
      return out;
    }

    // ---------- backend ----------
    async function postToBackend(rawText, operator){
      const gs1 = parseGS1(rawText);
      const payload = {
        item_uuid: gs1.key || rawText,
        product_code: gs1.gtin || null,
        expiry_date: gs1.exp || null,
        from_loc: 'FACTORY',
        to_loc: 'MAIN',
        operator: operator || 'SCAN'
      };

      await fetch('/api/stock', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });

      return { gs1, payload };
    }

    // ---------- camera open with robust steps ----------
    async function openCameraRobust(){
      cameraWrap.style.display = 'block';

      // 1) getUserMedia timeout
      setStatus('ğŸ¥ 1/3 å–å¾—ç›¸æ©Ÿä¸²æµä¸­â€¦');
      const s = await withTimeout(
        navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" } },
          audio: false
        }),
        6000,
        'getUserMedia'
      );

      stream = s;
      video.srcObject = stream;

      // 2) wait metadata
      setStatus('ğŸ¥ 2/3 ç­‰å¾…ç›¸æ©Ÿç•«é¢ readyâ€¦');
      await waitVideoReady(3500);

      // 3) play timeoutï¼ˆiOS å¸¸å¡ï¼‰
      setStatus('ğŸ¥ 3/3 å•Ÿå‹•æ’­æ”¾â€¦');
      await withTimeout(video.play(), 3000, 'video.play');

      // ensure dimensions exist
      await waitVideoReady(2000);
    }

    // ---------- ROI for rotate decode / OCR ----------
    function getScanRectOnVideo(){
      const wrapRect = cameraWrap.getBoundingClientRect();
      const boxRect = scanBox.getBoundingClientRect();
      return {
        x: (boxRect.left - wrapRect.left) / wrapRect.width,
        y: (boxRect.top - wrapRect.top) / wrapRect.height,
        w: boxRect.width / wrapRect.width,
        h: boxRect.height / wrapRect.height
      };
    }

    function captureROIToCanvas(rotationDeg = 0){
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      if (!vw || !vh) return false;

      const roi = getScanRectOnVideo();
      const sx = Math.max(0, Math.floor(roi.x * vw));
      const sy = Math.max(0, Math.floor(roi.y * vh));
      const sw = Math.min(vw - sx, Math.floor(roi.w * vw));
      const sh = Math.min(vh - sy, Math.floor(roi.h * vh));

      const rot = ((rotationDeg % 360) + 360) % 360;
      const outW = (rot === 90 || rot === 270) ? sh : sw;
      const outH = (rot === 90 || rot === 270) ? sw : sh;

      workCanvas.width = outW;
      workCanvas.height = outH;

      workCtx.save();
      workCtx.clearRect(0,0,outW,outH);

      if (rot === 0){
        workCtx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
      } else {
        workCtx.translate(outW/2, outH/2);
        workCtx.rotate(rot * Math.PI / 180);
        workCtx.drawImage(video, sx, sy, sw, sh, -sw/2, -sh/2, sw, sh);
      }
      workCtx.restore();
      return true;
    }

    async function tryDecodeFromCanvasOnce(){
      const rotations = [0, 90, 180, 270];
      for (const rot of rotations){
        const ok = captureROIToCanvas(rot);
        if (!ok) continue;
        const url = workCanvas.toDataURL('image/png', 1.0);
        try{
          const res = await reader.decodeFromImageUrl(url);
          return { text: res.getText(), rot };
        }catch(e){}
      }
      return null;
    }

    async function ocrFallback(){
      captureROIToCanvas(0);

      // grayscale + contrast
      const imgData = workCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        let v = (r*0.299 + g*0.587 + b*0.114);
        v = (v - 128) * 2.8 + 128;
        v = Math.max(0, Math.min(255, v));
        data[i] = data[i+1] = data[i+2] = v;
      }
      workCtx.putImageData(imgData, 0, 0);

      const url = workCanvas.toDataURL('image/jpeg', 0.92);

      const res = await Tesseract.recognize(url, 'eng', {
        logger: m => {
          if (m.status === 'recognizing text') {
            setStatus(`ğŸ§  OCR è¾¨è­˜ä¸­: ${Math.round(m.progress * 100)}%`);
          }
        }
      });

      let clean = (res.data.text || '')
        .replace(/\s+/g, '')
        .replace(/[\[\{]/g, '(').replace(/[\]\}]/g, ')')
        .replace(/O/g, '0')
        .replace(/[Il|]/g, '1')
        .replace(/S/g, '5')
        .replace(/B/g, '8');

      return clean;
    }

    // ---------- Start ----------
    async function start(){
      setBusy(true);
      setStatus('ğŸŸ£ start() è§¸ç™¼äº†ï¼šæº–å‚™é–‹ç›¸æ©Ÿâ€¦');

      // ä¿®æ­£ï¼šç›¸å®¹ä¸åŒç‰ˆæœ¬çš„ ZXing è¼‰å…¥æ–¹å¼
      const ZXing = window.ZXingBrowser || window.ZXing;
        if (!ZXing) {
            setBusy(false);
            setStatus('<b style="color:red">âŒ æ‰¾ä¸åˆ° ZXing å¥—ä»¶</b><br>è«‹æª¢æŸ¥ç¶²è·¯æˆ–è…³æœ¬è·¯å¾‘');
            return;
        }

      const { BrowserMultiFormatReader, BarcodeFormat, DecodeHintType } = ZXing;

      if (!window.ZXingBrowser) {
        setBusy(false);
        setStatus('<b style="color:red">âŒ ZXing æœªè¼‰å…¥</b><br>è«‹ç¢ºèª /libs/zxing/zxing-browser.min.js å¯è¢«å­˜å–');
        return;
      }

      // init zxing reader
      //const { BrowserMultiFormatReader, BarcodeFormat, DecodeHintType } = window.ZXingBrowser;
      const hints = new Map();
      hints.set(DecodeHintType.POSSIBLE_FORMATS, [
        BarcodeFormat.CODE_128,
        BarcodeFormat.QR_CODE,
        BarcodeFormat.DATA_MATRIX
      ]);
      hints.set(DecodeHintType.TRY_HARDER, true);
      reader = new BrowserMultiFormatReader(hints, 600);

      btnStart.disabled = true;
      btnStop.disabled = false;
      scanning = true;
      stopAllTimers();

      alert('æº–å‚™è«‹æ±‚æ¬Šé™');
      try{
        await openCameraRobust();
      } catch(e){
        stopEverything();
        setStatus(`<b style="color:red">âŒ é–‹ç›¸æ©Ÿå¡ä½/å¤±æ•—</b><br>${String(e?.message||e)}<br>
          å¯èƒ½åŸå› ï¼šæ¬Šé™æœªå…è¨± / WebView é™åˆ¶ / HTTPS å•é¡Œ`);
        return;
      }

      setBusy(false);
      setStatus('âœ… ç›¸æ©Ÿå·²å•Ÿå‹•ï¼Œè«‹æŠŠæ¢ç¢¼æ”¾å…¥æ¡†å…§');
      lastSeenAt = Date.now();

      // live scanning
      try{
        controls = await reader.decodeFromVideoDevice(null, video, async (result, err) => {
          if (!scanning) return;
          if (result) {
            const text = result.getText();
            lastSeenAt = Date.now();

            setBusy(true);
            setStatus(`âœ… æƒåˆ°ï¼š<br>${text}<br>æ­£åœ¨å…¥åº«â€¦`);

            try{
              await postToBackend(text, 'LIVE_SCAN');
              stopEverything();
              setStatus(`<b style="color:green">âœ… å…¥åº«æˆåŠŸ</b><br>${text}`);
              alert('âœ… å·²å…¥åº«ï¼');
            } catch(e){
              setBusy(false);
              setStatus(`<b style="color:red">âŒ å…¥åº« API å¤±æ•—</b><br>${String(e?.message||e)}`);
            }
          }
        });
      } catch(e){
        stopEverything();
        setStatus(`<b style="color:red">âŒ æƒæåˆå§‹åŒ–å¤±æ•—</b><br>${String(e?.message||e)}`);
        return;
      }

      // watchdog: 4s -> rotate; 10s more -> OCR
      watchdogTimer = setInterval(() => {
        if (!scanning) return;
        const since = Date.now() - lastSeenAt;

        if (since > 4000 && !rotateTryTimer){
          setStatus('ğŸ§­ å³æ™‚æƒæå°šæœªæˆåŠŸï¼Œå•Ÿå‹•æ—‹è½‰å®¹éŒ¯è§£ç¢¼â€¦ï¼ˆè«‹ä¿æŒç©©å®šï¼‰');

          rotateTryTimer = setInterval(async () => {
            if (!scanning) return;
            try{
              const found = await tryDecodeFromCanvasOnce();
              if (found?.text){
                lastSeenAt = Date.now();
                setBusy(true);
                setStatus(`âœ… æ—‹è½‰å®¹éŒ¯æˆåŠŸï¼ˆ${found.rot}Â°ï¼‰<br>${found.text}<br>æ­£åœ¨å…¥åº«â€¦`);

                try{
                  await postToBackend(found.text, `ROTATE_${found.rot}`);
                  stopEverything();
                  setStatus(`<b style="color:green">âœ… å…¥åº«æˆåŠŸï¼ˆæ—‹è½‰å®¹éŒ¯ï¼‰</b><br>${found.text}`);
                  alert('âœ… å·²å…¥åº«ï¼');
                } catch(e){
                  setBusy(false);
                  setStatus(`<b style="color:red">âŒ å…¥åº« API å¤±æ•—</b><br>${String(e?.message||e)}`);
                }
              }
            }catch(_){}
          }, 1200);

          ocrTimer = setTimeout(async () => {
            if (!scanning) return;
            setBusy(true);
            setStatus('ğŸ§  ä»æœªæˆåŠŸï¼Œå•Ÿå‹• OCR fallbackï¼ˆè®€äººçœ¼å­—ä¸²ï¼‰â€¦');

            try{
              const ocrText = await ocrFallback();
              const gs1 = parseGS1(ocrText);

              if (!gs1.key && !gs1.gtin && !gs1.exp) {
                setBusy(false);
                setStatus(`<b style="color:red">âŒ OCR ä»ç„¡æ³•è§£æ</b><br>è«‹æ›´è¿‘ã€è£œå…‰ã€é¿å…åå…‰æˆ–æ©«æ”¾æ¢ç¢¼ã€‚<br>OCR: ${ocrText}`);
                return;
              }

              setStatus(`âœ… OCR è®€åˆ°ï¼š<br>${ocrText}<br>æ­£åœ¨å…¥åº«â€¦`);
              await postToBackend(ocrText, 'OCR_FALLBACK');

              stopEverything();
              setStatus(`<b style="color:green">âœ… å…¥åº«æˆåŠŸï¼ˆOCRï¼‰</b><br>${ocrText}`);
              alert('âœ… å·²å…¥åº«ï¼ˆOCRï¼‰ï¼');
            } catch(e){
              setBusy(false);
              setStatus(`<b style="color:red">âŒ OCR fallback å‡ºéŒ¯</b><br>${String(e?.message||e)}`);
            }
          }, 10000);
        }
      }, 800);
    }

    function stop(){
      setStatus('â›” å·²åœæ­¢ã€‚');
      stopEverything();
    }

    // expose to onclick
    window.__startScan = start;
    window.__stopScan = stop;
  </script>
</body>
</html>
