<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>æ¥­å‹™ç«¯ - æƒæå…¥åº«ï¼ˆGS1/QR/DataMatrix + OCRï¼‰</title>

<style>
  body { font-family:-apple-system, sans-serif; padding:20px; background:#f4f4f9; color:#333; text-align:center; }
  .card { background:white; padding:20px; border-radius:15px; box-shadow:0 4px 15px rgba(0,0,0,0.1); }
  button { background:#7360f2; color:white; border:none; padding:16px; border-radius:10px; cursor:pointer; width:100%; font-size:16px; font-weight:bold; margin-top:10px; }
  .back-btn { background:#666; }
  .muted { color:#888; font-size:13px; margin:8px 0 12px; }
  #status { margin-top:12px; font-size:14px; color:#444; word-break:break-all; min-height:56px; }
  .spinner { display:none; margin:10px auto; width:30px; height:30px; border:3px solid #f3f3f3; border-top:3px solid #7360f2; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

  /* Camera area */
  .camera-wrap{
    position: relative;
    width: 100%;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #7360f2;
    background:#000;
  }
  video{
    width:100%;
    height:auto;
    display:block;
  }

  /* Scan overlay */
  .overlay{
    position:absolute;
    inset:0;
    pointer-events:none;
  }
  .mask{
    position:absolute;
    inset:0;
    background: rgba(0,0,0,0.35);
  }
  .scan-box{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:78%;
    height:42%;
    border: 2px solid rgba(255,255,255,0.95);
    border-radius: 14px;
    box-shadow: 0 0 0 9999px rgba(0,0,0,0.35);
  }
  .corner{
    position:absolute; width:22px; height:22px; border:3px solid #00ffb3;
  }
  .c1{left:-2px; top:-2px; border-right:none; border-bottom:none; border-radius:12px 0 0 0;}
  .c2{right:-2px; top:-2px; border-left:none; border-bottom:none; border-radius:0 12px 0 0;}
  .c3{left:-2px; bottom:-2px; border-right:none; border-top:none; border-radius:0 0 0 12px;}
  .c4{right:-2px; bottom:-2px; border-left:none; border-top:none; border-radius:0 0 12px 0;}

  .scan-line{
    position:absolute;
    left:6%;
    top:12%;
    width:88%;
    height:2px;
    background: linear-gradient(90deg, transparent, #00ffb3, transparent);
    filter: drop-shadow(0 0 4px rgba(0,255,179,0.8));
    animation: scanmove 1.4s ease-in-out infinite;
    opacity:0.95;
  }
  @keyframes scanmove{
    0%{ transform: translateY(0); }
    50%{ transform: translateY(calc(100% + 120px)); }
    100%{ transform: translateY(0); }
  }

  /* Debug canvas (used for rotation/OCR capture) */
  canvas#workCanvas { display:none; }
</style>
</head>

<body>
  <div class="card">
    <h2>ğŸ“· æƒæå…¥åº«ï¼ˆGS1-128 / QR / DataMatrixï¼‰</h2>
    <div class="muted">
      æŠŠæ¢ç¢¼æ”¾é€²æ¡†å…§ï¼ˆå»ºè­°è·é›¢ 10â€“15cmã€é¿å…åå…‰ï¼‰ã€‚<br>
      GS1-128 è‹¥æ˜¯å´æ”¾ï¼Œç³»çµ±æœƒè‡ªå‹•æ—‹è½‰å®¹éŒ¯ã€‚
    </div>

    <div class="camera-wrap" id="cameraWrap">
      <video id="video" autoplay muted playsinline></video>

      <div class="overlay">
        <div class="scan-box" id="scanBox">
          <div class="corner c1"></div>
          <div class="corner c2"></div>
          <div class="corner c3"></div>
          <div class="corner c4"></div>
          <div class="scan-line"></div>
        </div>
      </div>
    </div>

    <div class="spinner" id="spin"></div>
    <div id="status">å•Ÿå‹•ç›¸æ©Ÿä¸­â€¦</div>

    <button id="btnRestart">ğŸ”„ é‡æ–°é–‹å§‹æƒæ</button>
    <button class="back-btn" onclick="location.href='index.html'">â¬…ï¸ å›åˆ°ç¸½è¡¨</button>

    <!-- éš±è—å·¥ä½œ canvasï¼šç”¨ä¾†æˆªåœ– / æ—‹è½‰ / OCR -->
    <canvas id="workCanvas"></canvas>
  </div>

  <!-- OCRï¼ˆfallbackï¼‰ -->
  <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>

  <!-- ZXing -->
  <script type="module">
    import { BrowserMultiFormatReader, DecodeHintType, BarcodeFormat } 
      from "https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.5/+esm";

    const video = document.getElementById('video');
    const statusEl = document.getElementById('status');
    const spin = document.getElementById('spin');
    const btnRestart = document.getElementById('btnRestart');
    const cameraWrap = document.getElementById('cameraWrap');
    const scanBox = document.getElementById('scanBox');
    const workCanvas = document.getElementById('workCanvas');
    const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });

    // âœ… æ”¯æ´å¤šç¢¼åˆ¶ï¼šCode128(GS1-128), QR, DataMatrix
    const hints = new Map();
    hints.set(DecodeHintType.POSSIBLE_FORMATS, [
      BarcodeFormat.CODE_128,
      BarcodeFormat.QR_CODE,
      BarcodeFormat.DATA_MATRIX
    ]);
    hints.set(DecodeHintType.TRY_HARDER, true);

    const reader = new BrowserMultiFormatReader(hints, 600);

    let scanning = false;
    let lastSuccessAt = 0;
    let watchdogTimer = null;
    let rotateTryTimer = null;
    let ocrTimer = null;

    // -------------------------
    // GS1 parse (covers bracket & raw)
    // -------------------------
    function parseGS1(raw) {
      const s = String(raw || '').replace(/\s+/g, '').replace(/\((\d{2})\)/g, '$1');

      let i = 0;
      const out = {};
      const read = (n) => s.slice(i, i += n);

      while (i < s.length) {
        const ai = s.slice(i, i + 2);
        i += 2;

        if (ai === '01') out.gtin = read(14);
        else if (ai === '11') out.mfg = read(6);
        else if (ai === '17') out.exp = read(6);
        else if (ai === '21') { // å¯è®Šé•·ï¼ˆåºè™Ÿï¼‰â€” è‹¥ä½ æœªä¾†æœ‰ (21) ä¹Ÿåƒå¾—åˆ°
          out.sn = s.slice(i);
          break;
        }
        else if (ai === '10') { // å¯è®Šé•·ï¼ˆæ‰¹è™Ÿ/LOTï¼‰
          out.lot = s.slice(i);
          break;
        } else {
          // ä¸èªå¾—å°±åœï¼ˆé¿å…æ­»å¾ªç’°ï¼‰
          break;
        }
      }

      // ä½ çš„ key è¦å‰‡ï¼ˆå¦‚æœæœ‰ 21 ç”¨ 21ï¼Œæ²’æœ‰å°±ç”¨ 10ï¼‰
      const tail = (out.sn || out.lot || '');
      const serial8 = tail.replace(/-.+$/, '').slice(0, 8).toUpperCase();
      out.key = (out.mfg && out.exp && serial8) ? `${out.mfg}_${out.exp}_${serial8}` : '';

      return out;
    }

    // -------------------------
    // utilities
    // -------------------------
    function setStatus(html){ statusEl.innerHTML = html; }
    function setBusy(b){ spin.style.display = b ? 'block' : 'none'; }

    function stopAllTimers(){
      if (watchdogTimer) clearInterval(watchdogTimer);
      if (rotateTryTimer) clearInterval(rotateTryTimer);
      if (ocrTimer) clearTimeout(ocrTimer);
      watchdogTimer = rotateTryTimer = ocrTimer = null;
    }

    function getScanRectOnVideo(){
      // å–å¾— scanBox åœ¨ cameraWrap çš„ç›¸å°ä½ç½®ï¼ˆç™¾åˆ†æ¯”ï¼‰
      const wrapRect = cameraWrap.getBoundingClientRect();
      const boxRect = scanBox.getBoundingClientRect();

      const x = (boxRect.left - wrapRect.left) / wrapRect.width;
      const y = (boxRect.top - wrapRect.top) / wrapRect.height;
      const w = boxRect.width / wrapRect.width;
      const h = boxRect.height / wrapRect.height;

      return { x, y, w, h };
    }

    function captureROIToCanvas(rotationDeg = 0){
      // æŠŠ video ç•«åˆ° canvasï¼ˆåªæˆª scan box å€åŸŸï¼‰ï¼Œä¸¦å¯æ—‹è½‰
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      if (!vw || !vh) return false;

      const roi = getScanRectOnVideo();

      // ROI in video pixel coords
      const sx = Math.max(0, Math.floor(roi.x * vw));
      const sy = Math.max(0, Math.floor(roi.y * vh));
      const sw = Math.min(vw - sx, Math.floor(roi.w * vw));
      const sh = Math.min(vh - sy, Math.floor(roi.h * vh));

      // å…ˆè£åˆ‡å‡º ROI åˆ°ä¸€å€‹æš«å­˜ canvasï¼ˆç”¨ workCanvas ç›´æ¥è™•ç†ï¼‰
      // æ—‹è½‰å¾Œçš„ canvas å°ºå¯¸
      const rot = ((rotationDeg % 360) + 360) % 360;
      const outW = (rot === 90 || rot === 270) ? sh : sw;
      const outH = (rot === 90 || rot === 270) ? sw : sh;

      workCanvas.width = outW;
      workCanvas.height = outH;

      workCtx.save();
      workCtx.clearRect(0,0,outW,outH);

      // æ—‹è½‰ç¹ªåˆ¶
      if (rot === 0){
        workCtx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
      } else {
        workCtx.translate(outW/2, outH/2);
        workCtx.rotate(rot * Math.PI / 180);
        // æ—‹è½‰å¾Œï¼ŒåŸ ROI ç•«åœ¨ä¸­å¿ƒ
        workCtx.drawImage(video, sx, sy, sw, sh, -sw/2, -sh/2, sw, sh);
      }

      workCtx.restore();
      return true;
    }

    async function tryDecodeFromCanvasOnce(){
      // å˜—è©¦æ—‹è½‰å®¹éŒ¯ 0/90/180/270
      const rotations = [0, 90, 180, 270];

      for (const rot of rotations){
        const ok = captureROIToCanvas(rot);
        if (!ok) continue;

        // ç”¨ dataURL èµ° decodeï¼ˆç°¡å–®ç©©ï¼‰
        const url = workCanvas.toDataURL('image/png', 1.0);
        try{
          const res = await reader.decodeFromImageUrl(url);
          return { text: res.getText(), rot };
        }catch(e){
          // continue
        }
      }
      return null;
    }

    // OCR fallbackï¼šåªåœ¨ ROI ä¸Šè·‘ï¼Œä¸¦åŠ  whitelist è®“æˆåŠŸç‡é«˜
    async function ocrFallbackFromCanvas(){
      // å…ˆåšã€Œåæ–‡å­—ã€é è™•ç†ï¼šç°éš + é«˜å°æ¯”
      const imgData = workCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
      const data = imgData.data;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        // grayscale
        let v = (r*0.299 + g*0.587 + b*0.114);
        // contrast boost
        v = (v - 128) * 2.8 + 128;
        // clamp
        v = Math.max(0, Math.min(255, v));
        data[i] = data[i+1] = data[i+2] = v;
      }
      workCtx.putImageData(imgData, 0, 0);

      const url = workCanvas.toDataURL('image/jpeg', 0.92);

      const res = await Tesseract.recognize(url, 'eng', {
        logger: m => {
          if (m.status === 'recognizing text') {
            setStatus(`ğŸ§  OCR è¾¨è­˜ä¸­: ${Math.round(m.progress * 100)}%`);
          }
        }
      });

      // æ¸…ç†å¸¸è¦‹èª¤è®€
      let clean = (res.data.text || '')
        .replace(/\s+/g, '')
        .replace(/[\[\{]/g, '(')
        .replace(/[\]\}]/g, ')')
        .replace(/O/g, '0')
        .replace(/[Il|]/g, '1')
        .replace(/S/g, '5')
        .replace(/B/g, '8');

      return clean;
    }

    async function postToBackend({ rawText, formatNote }){
      // GS1-128 èµ° parseï¼›QR/DataMatrix å¯èƒ½æ˜¯è‡ªè¨‚ payload
      const gs1 = parseGS1(rawText);

      // ä½ çš„èˆŠæ¬„ä½éœ€è¦ item_uuid / product_code / expiry_date
      // - è‹¥æ˜¯ GS1ï¼šç”¨ key/gtin/exp
      // - è‹¥æ˜¯ QR/DataMatrixï¼šå°±æŠŠæ•´æ®µç•¶ item_uuidï¼ˆä½ å¯è‡ªè¡Œæ”¹ mappingï¼‰
      const payload = {
        item_uuid: gs1.key || rawText,
        product_code: gs1.gtin || null,
        expiry_date: gs1.exp || null,
        from_loc: 'FACTORY',
        to_loc: 'MAIN',
        operator: formatNote || 'SCAN'
      };

      await fetch('/api/stock', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });

      return { gs1, payload };
    }

    // -------------------------
    // Start live scanning
    // -------------------------
    async function startScan(){
      stopAllTimers();
      setBusy(true);
      setStatus('ğŸ¥ å•Ÿå‹•ç›¸æ©Ÿä¸­â€¦');
      scanning = true;

      try{
        // decodeFromVideoDeviceï¼šæˆåŠŸæ™‚ callback æœƒä¸€ç›´å›ä¾†ï¼Œæˆ‘å€‘æŠ“åˆ°ä¸€æ¬¡å°± reset åœæ­¢
        await reader.decodeFromVideoDevice(
          null,
          video,
          async (result, err) => {
            if (!scanning) return;

            if (result) {
              const text = result.getText();
              lastSuccessAt = Date.now();

              setBusy(true);
              setStatus(`âœ… å·²æƒåˆ°è³‡æ–™ï¼Œè™•ç†ä¸­â€¦<br>${text}`);

              try{
                // ç›´æ¥é€å¾Œç«¯
                const out = await postToBackend({ rawText: text, formatNote: 'LIVE_SCAN' });

                setStatus(
                  `<b style="color:green">âœ… å…¥åº«æˆåŠŸ</b><br>` +
                  `Raw: ${text}<br>` +
                  `${out.gs1.gtin ? `GTIN(01): ${out.gs1.gtin}<br>` : ''}` +
                  `${out.gs1.mfg ? `MFG(11): ${out.gs1.mfg}<br>` : ''}` +
                  `${out.gs1.exp ? `EXP(17): ${out.gs1.exp}<br>` : ''}` +
                  `${(out.gs1.lot||out.gs1.sn) ? `TAIL(10/21): ${(out.gs1.lot||out.gs1.sn)}<br>` : ''}` +
                  `${out.gs1.key ? `KEY: ${out.gs1.key}` : ''}`
                );

                reader.reset(); // åœæ­¢ç›¸æ©Ÿæƒæ
                scanning = false;
                setBusy(false);
                alert('âœ… å·²å…¥åº«ï¼');

              } catch(e){
                setBusy(false);
                setStatus(`<b style="color:red">âŒ é€å‡ºå…¥åº«å¤±æ•—</b><br>${String(e?.message||e)}`);
              }
            }
          }
        );

      } catch(e){
        setBusy(false);
        setStatus(`<b style="color:red">âŒ ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—</b><br>è«‹ç¢ºèªä½¿ç”¨ https/localhostï¼Œä¸¦å…è¨±ç›¸æ©Ÿæ¬Šé™ã€‚`);
        scanning = false;
        return;
      }

      // Watchdogï¼šè‹¥ 4 ç§’éƒ½æƒä¸åˆ° â†’ è§¸ç™¼ã€Œæ—‹è½‰å®¹éŒ¯è§£ç¢¼ã€æ¯ 1.2 ç§’è©¦ä¸€æ¬¡
      watchdogTimer = setInterval(() => {
        if (!scanning) return;

        const now = Date.now();
        const since = now - lastSuccessAt;

        if (since > 4000 && !rotateTryTimer){
          setStatus('ğŸ§­ å³æ™‚æƒæå°šæœªæˆåŠŸï¼Œå•Ÿå‹•æ—‹è½‰å®¹éŒ¯è§£ç¢¼â€¦ï¼ˆè«‹ä¿æŒç©©å®šï¼‰');

          rotateTryTimer = setInterval(async () => {
            if (!scanning) return;

            try{
              const found = await tryDecodeFromCanvasOnce();
              if (found?.text){
                lastSuccessAt = Date.now();
                setStatus(`âœ… æ—‹è½‰å®¹éŒ¯è§£ç¢¼æˆåŠŸï¼ˆrot=${found.rot}Â°ï¼‰<br>${found.text}`);

                // é€å¾Œç«¯
                const out = await postToBackend({ rawText: found.text, formatNote: `ROTATE_${found.rot}` });

                reader.reset();
                scanning = false;
                stopAllTimers();
                setBusy(false);

                setStatus(
                  `<b style="color:green">âœ… å…¥åº«æˆåŠŸ</b><br>` +
                  `Raw: ${found.text}<br>` +
                  `${out.gs1.gtin ? `GTIN(01): ${out.gs1.gtin}<br>` : ''}` +
                  `${out.gs1.mfg ? `MFG(11): ${out.gs1.mfg}<br>` : ''}` +
                  `${out.gs1.exp ? `EXP(17): ${out.gs1.exp}<br>` : ''}` +
                  `${(out.gs1.lot||out.gs1.sn) ? `TAIL(10/21): ${(out.gs1.lot||out.gs1.sn)}<br>` : ''}` +
                  `${out.gs1.key ? `KEY: ${out.gs1.key}` : ''}`
                );

                alert('âœ… å·²å…¥åº«ï¼');
              }
            }catch(_){}
          }, 1200);

          // è‹¥å†é 10 ç§’ä»ç„¶æ²’æˆåŠŸ â†’ OCR fallbackï¼ˆåªåšä¸€æ¬¡ï¼‰
          ocrTimer = setTimeout(async () => {
            if (!scanning) return;
            setBusy(true);
            setStatus('ğŸ§  ä»æœªæˆåŠŸï¼Œå•Ÿå‹• OCR fallbackï¼ˆè®€äººçœ¼å­—ä¸²ï¼‰â€¦');

            try{
              // OCR ä¹Ÿåšæ—‹è½‰å®¹éŒ¯ï¼šå…ˆæŠ“ 0/90/180/270 æœ€å¯èƒ½å«æ–‡å­—çš„é‚£å¼µå† OCR
              // é€™è£¡ç°¡åŒ–ï¼šç›´æ¥ç”¨ 0/90/180/270 è©¦ decode ä¸€è¼ªå¤±æ•—å¾Œï¼Œå– 0 åº¦ç•«é¢è·‘ OCR
              captureROIToCanvas(0);

              const ocrText = await ocrFallbackFromCanvas();

              // OCR è®€åˆ°æ‹¬è™Ÿç‰ˆæœ¬ä¹Ÿ OKï¼ˆparseGS1 æœƒè™•ç†ï¼‰
              setStatus(`<b>OCR è®€åˆ°ï¼š</b><br>${ocrText}`);

              // æœ€å°‘è¦èƒ½è§£æå‡º key æˆ–åƒä½ ç¯„ä¾‹é‚£ç¨® (01)(11)(17)(10) çš„çµæ§‹
              const gs1 = parseGS1(ocrText);
              if (!gs1.key && !gs1.gtin && !gs1.exp) {
                setBusy(false);
                setStatus(`<b style="color:red">âŒ OCR ä»ç„¡æ³•è§£æ</b><br>è«‹æ›´è¿‘ã€è£œå…‰ã€é¿å…åå…‰ï¼Œæˆ–æŠŠæ¢ç¢¼æ©«æ”¾ã€‚<br>OCR: ${ocrText}`);
                return;
              }

              const out = await postToBackend({ rawText: ocrText, formatNote: 'OCR_FALLBACK' });

              reader.reset();
              scanning = false;
              stopAllTimers();
              setBusy(false);

              setStatus(
                `<b style="color:green">âœ… OCR å…¥åº«æˆåŠŸ</b><br>` +
                `OCR: ${ocrText}<br>` +
                `${out.gs1.gtin ? `GTIN(01): ${out.gs1.gtin}<br>` : ''}` +
                `${out.gs1.mfg ? `MFG(11): ${out.gs1.mfg}<br>` : ''}` +
                `${out.gs1.exp ? `EXP(17): ${out.gs1.exp}<br>` : ''}` +
                `${(out.gs1.lot||out.gs1.sn) ? `TAIL(10/21): ${(out.gs1.lot||out.gs1.sn)}<br>` : ''}` +
                `${out.gs1.key ? `KEY: ${out.gs1.key}` : ''}`
              );

              alert('âœ… å·²å…¥åº«ï¼ˆOCR fallbackï¼‰ï¼');

            } catch(e){
              setBusy(false);
              setStatus(`<b style="color:red">âŒ OCR fallback å‡ºéŒ¯</b><br>${String(e?.message||e)}`);
            }
          }, 10000);
        }
      }, 800);

      // åˆå§‹çµ¦å€‹æ™‚é–“æˆ³
      lastSuccessAt = Date.now();
      setBusy(false);
      setStatus('âœ… ç›¸æ©Ÿå·²å•Ÿå‹•ï¼Œè«‹æŠŠæ¢ç¢¼æ”¾å…¥æ¡†å…§');
    }

    btnRestart.onclick = () => {
      try { reader.reset(); } catch(_){}
      scanning = false;
      stopAllTimers();
      startScan();
    };

    // auto start
    startScan();
  </script>

</body>
</html>
