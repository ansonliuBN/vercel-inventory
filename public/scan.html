<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>æ™ºèƒ½è¾¨è­˜å…¥åº« - ZXingå„ªå…ˆ + å…¨åœ–OCRæ—‹è½‰ä¿åº•ï¼ˆGS1-128/UDIï¼‰</title>

<link rel="icon" href="data:,">

<style>
  body { font-family:-apple-system, sans-serif; padding:15px; background:#f4f4f9; text-align:center; margin:0; }
  .card { background:white; padding:15px; border-radius:15px; box-shadow:0 4px 15px rgba(0,0,0,0.1); max-width: 600px; margin: auto; }

  .btn-group { display: flex; gap: 10px; margin-top: 15px; }
  button { flex: 1; padding: 15px; border-radius: 10px; border: none; cursor: pointer; font-size: 16px; font-weight: bold; color: white; transition: 0.3s; }
  .btn-cam { background: #7360f2; }
  .btn-file { background: #2d9cdb; }
  .btn-snap { background: #27ae60; width: 100%; margin-top: 10px; font-size: 18px; }
  .btn-import { background: #27ae60; width: 100%; margin-top: 15px; font-size: 20px; box-shadow: 0 4px 10px rgba(39,174,96,0.3); }
  .btn-back { background: #666; width: auto; font-size: 14px; float: left; padding: 8px 15px; }

  .camera-wrap {
    position: relative;
    width: 100%;
    aspect-ratio: 9/16;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #ddd;
    background:#000;
    margin-top: 15px;
    display: none;
  }

  video, #photoPreview { width:100%; height:100%; object-fit: cover; }
  #photoPreview { display: none; }

  .overlay { position:absolute; inset:0; pointer-events:none; }

  /* ä½¿ç”¨è€…å°æº–çš„é•·æ¢æ¡†ï¼ˆåƒ… UI guideï¼‰ */
  .scan-box {
    position:absolute;
    left:50%;
    top:52%;
    transform:translate(-50%,-50%);
    width:92%;
    height:22%;
    border:1px solid rgba(255,255,255,0.28);
    border-radius:12px;
    box-shadow:0 0 0 9999px rgba(0,0,0,0.55);
  }

  .corner { position:absolute; width:20px; height:20px; border:4px solid #00ffb3; }
  .c1 { left:-2px; top:-2px; border-right:none; border-bottom:none; border-top-left-radius:12px; }
  .c2 { right:-2px; top:-2px; border-left:none; border-bottom:none; border-top-right-radius:12px; }
  .c3 { left:-2px; bottom:-2px; border-right:none; border-top:none; border-bottom-left-radius:12px; }
  .c4 { right:-2px; bottom:-2px; border-left:none; border-top:none; border-bottom-right-radius:12px; }
  .scan-line { position:absolute; left:5%; top:10%; width:90%; height:2px; background:linear-gradient(90deg,transparent,#00ffb3,transparent); animation: move 1.8s infinite; }
  @keyframes move { 0%, 100% { top: 10%; } 50% { top: 90%; } }

  .review-form { text-align: left; background: #f9f9ff; padding: 15px; border-radius: 12px; border: 2px solid #7360f2; margin-top: 15px; display: none; animation: fadeIn 0.5s; }
  @keyframes fadeIn { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }
  .review-form label { font-size: 13px; color: #555; font-weight: bold; display: block; margin-top: 10px; }
  .review-form input, .review-form select, .review-form textarea { width: 100%; padding: 12px; border: 1px solid #ccc; border-radius: 8px; font-size: 16px; box-sizing: border-box; margin-top: 4px; }

  .loader { display:none; margin:10px auto; width:30px; height:30px; border:3px solid #f3f3f3; border-top:3px solid #7360f2; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
  canvas#workCanvas { display:none; }

  .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:12px; background:#eef; color:#333; margin-top:10px; }

  .debug-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
    margin-top:10px;
  }
  .debug-card{
    background:#fff;
    border:1px solid #ddd;
    border-radius:10px;
    padding:8px;
  }
  .debug-card b{ font-size:12px; color:#555; display:block; margin-bottom:6px; }
  .debug-card img{ width:100%; border-radius:8px; border:1px solid #eee; background: #fff; }
</style>
</head>
<body>

<div class="card">
  <button class="btn-back" onclick="location.href='index.html'">â¬…ï¸ è¿”å›ç¸½è¡¨</button>
  <div style="clear: both;"></div>
  <h2>ğŸ“¦ æ™ºèƒ½å…¥åº«è¤‡æ ¸</h2>

  <div class="btn-group" id="modeSelect">
    <button class="btn-cam" onclick="startCamera()">ğŸ“¸ é–‹å•Ÿç›¸æ©Ÿ</button>
    <button class="btn-file" onclick="document.getElementById('fileInput').click()">ğŸ“ ä¸Šå‚³ç…§ç‰‡</button>
  </div>
  <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileUpload(event)">

  <div class="camera-wrap" id="displayArea">
    <video id="video" autoplay muted playsinline></video>
    <img id="photoPreview" alt="preview">
    <div class="overlay" id="guidelines">
      <div class="scan-box">
        <div class="corner c1"></div><div class="corner c2"></div>
        <div class="corner c3"></div><div class="corner c4"></div>
        <div class="scan-line"></div>
      </div>
    </div>
  </div>

  <!-- ä¿ç•™æ‹ç…§æŒ‰éˆ• -->
  <button id="btnSnap" class="btn-snap" onclick="takeSnapshot()" style="display:none;">ğŸ“¸ é»æ“Šæ‹ç…§ä¸¦åˆ†æ</button>

  <div class="loader" id="loader"></div>
  <div id="sourcePill" class="pill" style="display:none;"></div>

  <div id="reviewArea" class="review-form">
    <h3 style="margin:0; color:#7360f2; border-bottom:1px solid #ddd; padding-bottom:8px;">ğŸ” è¾¨è­˜çµæœç¢ºèª</h3>

    <label>åŸå§‹è¾¨è­˜å…¨æ–‡ï¼ˆZXing + OCRï¼‰ï¼š</label>
    <textarea id="rawAll" style="min-height:200px; white-space:pre-wrap;" placeholder="å°šæœªè¾¨è­˜åˆ°ä»»ä½•æ–‡å­—"></textarea>

    <div class="debug-grid">
      <div class="debug-card">
        <b>WORKCANVAS_THUMBï¼ˆåŸåœ–ç¸®åœ–ï¼‰</b>
        <img id="imgWorkThumb" alt="work thumb">
      </div>
      <div class="debug-card">
        <b>SCAN_CROPï¼ˆå¤§ROIåˆ‡åœ–ï¼šæ¢ç¢¼+æ–‡å­—ï¼‰</b>
        <img id="imgScanCrop" alt="scan crop">
      </div>
      <div class="debug-card">
        <b>ZXING_FEEDï¼ˆå¯¦éš›é¤µ ZXing çš„é‚£å¡Šï¼‰</b>
        <img id="imgZxingFeed" alt="zxing feed">
      </div>
      <div class="debug-card">
        <b>OCR_FEEDï¼ˆæ—‹è½‰å¾Œå…¨åœ–OCRï¼‰</b>
        <img id="imgOcrRaw" alt="ocr raw">
      </div>
      <div class="debug-card">
        <b>OCR_FEED_ENHï¼ˆäºŒå€¼åŒ–ï¼‰</b>
        <img id="imgOcrEnh" alt="ocr enh">
      </div>
    </div>

    <!-- âœ… æ–°å¢ï¼šGTIN -->
    <label>GTINï¼ˆ(01) å¾Œ 14 ç¢¼ï¼›æœƒå¯«å…¥è³‡æ–™åº« item_uuidï¼‰ï¼š</label>
    <input type="text" id="editGtin" placeholder="å°šæœªåµæ¸¬">

    <label>æœ‰æ•ˆæ—¥æœŸï¼ˆ(17) å¾Œ 6 ç¢¼ â†’ è½‰æˆ yyyyå¹´mmæœˆddæ—¥ï¼‰ï¼š</label>
    <input type="text" id="editExp" placeholder="å°šæœªåµæ¸¬">

    <label>LOT / Serialï¼ˆåªæŠ“ (21) å¾Œé¢çš„å€¼ï¼‰ï¼š</label>
    <input type="text" id="editLot" placeholder="å°šæœªåµæ¸¬">

    <label>å…¥åº«æ•¸é‡ (ä»¥ 10 ç‚ºå–®ä½):</label>
    <select id="editQty">
      <option value="10">10</option><option value="20">20</option>
      <option value="30">30</option><option value="40">40</option>
      <option value="50">50</option><option value="100">100</option>
    </select>

    <button class="btn-import" onclick="finalSubmit()">âœ… ç¢ºèªè³‡æ–™ï¼ŒåŒ¯å…¥åº«å­˜</button>
    <button onclick="location.reload()" style="background:#eee; color:#444; width:100%; margin-top:10px; font-size:14px;">ğŸ”„ é‡æ‹ä¸€å¼µ</button>
  </div>

  <div id="status" style="margin-top:10px; font-size:13px; color:#888;"></div>
  <canvas id="workCanvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/zxing-wasm@2.2.1/dist/iife/reader/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@7/dist/tesseract.min.js"></script>

<script>
  const video = document.getElementById('video');
  const preview = document.getElementById('photoPreview');
  const loader = document.getElementById('loader');
  const workCanvas = document.getElementById('workCanvas');
  const ctx = workCanvas.getContext('2d', { willReadFrequently: true });
  let stream = null;

  // ===== Auto tracking (ZXing only) =====
  let autoTimer = null;
  let autoBusy = false;
  let autoFound = false;
  let zxingFailCount = 0;
  const AUTO_INTERVAL_MS = 280;
  const ZXING_FAIL_THRESHOLD_FOR_OCR = 3;

  function setStatus(msg) { document.getElementById('status').innerText = msg; }
  function showSourcePill(source) {
    const pill = document.getElementById('sourcePill');
    pill.style.display = 'inline-block';
    pill.textContent = `SOURCE: ${source}`;
  }

  function stopStream() {
    try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch(e) {}
    stream = null;
  }
  function stopAutoTrack() {
    if (autoTimer) clearInterval(autoTimer);
    autoTimer = null;
  }

  function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(r.result);
      r.onerror = reject;
      r.readAsDataURL(file);
    });
  }

  // ===== Text normalize / GS1 =====
  function normalizeTextKeepParens(raw) {
    return (raw || "")
      .replace(/\u00A0/g, " ")
      .replace(/[ \t\r]+/g, " ")
      .replace(/\n+/g, "\n")
      .replace(/[Il|]/g, '1')
      .replace(/O/g, '0');
  }
  function compact(raw) {
    return normalizeTextKeepParens(raw).replace(/\s+/g, '');
  }

  function hasGS1Core(text) {
    const s = compact(text);
    const has01 = /(?:\(?01\)?)(\d{14})/.test(s);
    const has17 = /(?:\(?17\)?)(\d{6})/.test(s);
    return has01 && has17;
  }

  // âœ… åªæŠ“ (21) ç•¶ LOT/Serialï¼›ä¸å† fallback (10)
  function extractGS1Data(text) {
    const s = compact(text);

    const m01 = s.match(/\(01\)(\d{14})/) || s.match(/01(\d{14})/);
    const m17 = s.match(/\(17\)(\d{6})/) || s.match(/17(\d{6})/);

    // (21) å¯è®Šé•·åº¦ï¼šé‡åˆ°ä¸‹ä¸€å€‹ AI æˆ–çµå°¾å°±åœ
    const stop = "(?:\\(?01\\)?|\\(?11\\)?|\\(?17\\)?|\\(?10\\)?|\\(?21\\)?|$)";
    const re21 = new RegExp("\\(21\\)([A-Z0-9\\-]{1,40})(?=" + stop + ")", "i");
    const m21 = s.match(re21) || s.match(/21([A-Z0-9\-]{1,40})(?=(?:\(?01\)?|\(?11\)?|\(?17\)?|\(?10\)?|\(?21\)?|$))/i);

    return {
      gtin: m01 ? m01[1] : "",
      exp:  m17 ? m17[1] : "",
      lot:  (m21 && m21[1]) ? m21[1] : ""
    };
  }

  // âœ… æŠŠ YYMMDD è½‰æˆ yyyyå¹´mmæœˆddæ—¥ï¼ˆé è¨­ 20YYï¼‰
  function yymmddToZhDate(yymmdd) {
    const v = (yymmdd || "").replace(/\D/g, "");
    if (v.length !== 6) return "";
    const yy = v.slice(0,2);
    const mm = v.slice(2,4);
    const dd = v.slice(4,6);

    const year = 2000 + parseInt(yy, 10);
    const m = parseInt(mm, 10);
    const d = parseInt(dd, 10);
    if (!Number.isFinite(year) || m < 1 || m > 12 || d < 1 || d > 31) return "";
    return `${year}å¹´${mm}æœˆ${dd}æ—¥`;
  }

  // ===== Canvas helpers =====
  function drawBase64ToWorkCanvas(base64) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        workCanvas.width = img.width;
        workCanvas.height = img.height;
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, workCanvas.width, workCanvas.height);
        ctx.drawImage(img, 0, 0);
        ctx.restore();
        resolve();
      };
      img.onerror = reject;
      img.src = base64;
    });
  }

  function canvasToPreviewURL(canvas) { return canvas.toDataURL("image/png"); }

  function makeThumb(canvas, maxW=420, maxH=420) {
    const w = canvas.width, h = canvas.height;
    const s = Math.min(maxW / w, maxH / h, 1);
    const c = document.createElement("canvas");
    c.width = Math.max(1, Math.floor(w * s));
    c.height = Math.max(1, Math.floor(h * s));
    const g = c.getContext("2d");
    g.imageSmoothingEnabled = true;
    g.fillStyle = "#fff";
    g.fillRect(0,0,c.width,c.height);
    g.drawImage(canvas, 0, 0, c.width, c.height);
    return c;
  }

  function getBigRoiRect(centerRatioY = 0.52) {
    const cw = workCanvas.width, ch = workCanvas.height;
    const boxW = cw * 0.94;
    const boxH = ch * 0.46;
    const cx = cw * 0.5;
    const cy = ch * centerRatioY;
    const x = Math.max(0, Math.floor(cx - boxW / 2));
    const y = Math.max(0, Math.floor(cy - boxH / 2));
    return { x, y, w: Math.floor(boxW), h: Math.floor(boxH) };
  }

  function cropCanvas(rect, scale = 1.8) {
    const c = document.createElement("canvas");
    c.width = Math.max(10, Math.floor(rect.w * scale));
    c.height = Math.max(10, Math.floor(rect.h * scale));
    const g = c.getContext("2d");
    g.fillStyle = "#fff";
    g.fillRect(0, 0, c.width, c.height);
    g.imageSmoothingEnabled = false;

    const sx = Math.max(0, Math.min(workCanvas.width - 1, rect.x));
    const sy = Math.max(0, Math.min(workCanvas.height - 1, rect.y));
    const sw = Math.max(1, Math.min(workCanvas.width - sx, rect.w));
    const sh = Math.max(1, Math.min(workCanvas.height - sy, rect.h));
    g.drawImage(workCanvas, sx, sy, sw, sh, 0, 0, c.width, c.height);
    return c;
  }

  function cropSub(canvas, x, y, w, h) {
    const c = document.createElement('canvas');
    c.width = Math.max(1, Math.floor(w));
    c.height = Math.max(1, Math.floor(h));
    const g = c.getContext('2d');
    g.fillStyle = "#fff";
    g.fillRect(0, 0, c.width, c.height);
    g.imageSmoothingEnabled = false;
    g.drawImage(canvas, x, y, w, h, 0, 0, c.width, c.height);
    return c;
  }

  function rotateCanvas(src, deg) {
    const rad = deg * Math.PI / 180;
    const w = src.width, h = src.height;
    const c = document.createElement('canvas');
    const g = c.getContext('2d');
    if (deg % 180 !== 0) { c.width = h; c.height = w; } else { c.width = w; c.height = h; }
    g.fillStyle = "#fff";
    g.fillRect(0, 0, c.width, c.height);
    g.imageSmoothingEnabled = false;
    g.translate(c.width/2, c.height/2);
    g.rotate(rad);
    g.drawImage(src, -w/2, -h/2);
    return c;
  }

  function canvasToJpegURL(canvas, q=0.92) { return canvas.toDataURL("image/jpeg", q); }

  // ===== ZXing (fast) =====
  function ensureZXingWasmLoaded() {
    if (!window.ZXingWASM || typeof window.ZXingWASM.readBarcodes !== "function") {
      throw new Error("zxing-wasm æœªè¼‰å…¥æˆåŠŸï¼ˆindex.jsï¼‰");
    }
  }
  async function prepareZXingReaderModuleOnce() {
    ensureZXingWasmLoaded();
    if (prepareZXingReaderModuleOnce._done) return;
    prepareZXingReaderModuleOnce._done = true;
    const ZX = window.ZXingWASM;
    ZX.prepareZXingModule({
      overrides: { locateFile: (path, prefix) => path.endsWith(".wasm") ? "/zxing_reader.wasm" : (prefix + path) },
      fireImmediately: true
    });
  }
  async function decodeBarcodeWithZXing(canvasForZXing) {
    await prepareZXingReaderModuleOnce();
    const g = canvasForZXing.getContext("2d", { willReadFrequently: true });
    const imgData = g.getImageData(0,0,canvasForZXing.width, canvasForZXing.height);
    const results = await window.ZXingWASM.readBarcodes(imgData, { tryHarder: true, maxNumberOfSymbols: 2 });
    if (!results || !results.length) return "";
    for (const r of results) {
      const t = r?.text || "";
      if (t && (hasGS1Core(t) || /(?:\(?01\)?\d{14})/.test(compact(t)))) return t;
    }
    return results[0].text || "";
  }
  function buildCode128Candidates(bigCrop) {
    const W = bigCrop.width, H = bigCrop.height;
    const roiW = Math.floor(W * 0.96);
    const roiH = Math.floor(H * 0.78);
    const left = Math.floor((W - roiW) / 2);
    const stepY = Math.max(1, Math.floor(H * 0.10));
    const list = [];
    for (let y=0; y<=Math.max(0, H - roiH); y+=stepY) {
      list.push({ name:`WIN_Y${y}`, canvas: cropSub(bigCrop, left, y, roiW, roiH) });
    }
    list.unshift({ name:`FULL_BIG`, canvas: bigCrop });
    return list;
  }
  async function zxingScanBig(bigCrop, debug) {
    const candidates = buildCode128Candidates(bigCrop);
    const angles = [0, 90, 270, 180];
    for (const item of candidates) {
      for (const deg of angles) {
        const feed = (deg===0) ? item.canvas : rotateCanvas(item.canvas, deg);
        let t = "";
        try { t = await decodeBarcodeWithZXing(feed); } catch(e){ t = ""; }
        if (debug) debug.push(`[ZXING][${item.name}][${deg}] ${t ? t : "(empty)"}`);
        if (t && hasGS1Core(t)) {
          if (debug) debug.push(`[ZXING][BEST] ${item.name} @ ${deg}`);
          return { text:t, cand:item.name, deg, feedCanvas: feed };
        }
      }
    }
    if (debug) debug.push(`[ZXING][BEST] -`);
    return { text:"", cand:"", deg:null, feedCanvas:null };
  }

  // ===== OCR (full image rotate + regex) =====
  async function ensureTesseractLoaded() {
    if (!window.Tesseract || typeof window.Tesseract.createWorker !== "function") {
      throw new Error("Tesseract.js v7 æœªè¼‰å…¥æˆåŠŸ");
    }
  }
  let ocrWorker = null;
  async function getOcrWorker() {
    await ensureTesseractLoaded();
    if (ocrWorker) return ocrWorker;
    setStatus("ğŸ§  åˆå§‹åŒ– OCR å¼•æ“ (Tesseract v7)...");
    ocrWorker = await Tesseract.createWorker("eng");
    return ocrWorker;
  }

  function enhanceForOcr(baseCanvas, contrast=1.7, threshold=170) {
    const c = document.createElement("canvas");
    c.width = baseCanvas.width;
    c.height = baseCanvas.height;
    const g = c.getContext("2d");
    g.fillStyle = "#fff";
    g.fillRect(0,0,c.width,c.height);
    g.drawImage(baseCanvas, 0, 0);
    const img = g.getImageData(0,0,c.width,c.height);
    const d = img.data;
    for (let i=0;i<d.length;i+=4){
      const r=d[i], gg=d[i+1], b=d[i+2];
      let y = 0.299*r + 0.587*gg + 0.114*b;
      y = (y - 128) * contrast + 128;
      y = Math.max(0, Math.min(255, y));
      const v = (y > threshold) ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
    g.putImageData(img,0,0);
    return c;
  }

  function downscaleIfNeeded(src, maxSide = 2200) {
    const w = src.width, h = src.height;
    const max = Math.max(w,h);
    if (max <= maxSide) return src;
    const scale = maxSide / max;
    const c = document.createElement("canvas");
    c.width = Math.max(1, Math.floor(w * scale));
    c.height = Math.max(1, Math.floor(h * scale));
    const g = c.getContext("2d");
    g.fillStyle = "#fff";
    g.fillRect(0,0,c.width,c.height);
    g.imageSmoothingEnabled = true;
    g.drawImage(src, 0, 0, c.width, c.height);
    return c;
  }

  async function ocrFullImageRotate(workCanvasFull, debug) {
    const worker = await getOcrWorker();

    const opts = {
      tessedit_char_whitelist: "0123456789()ABCDEFGHIJKLMNOPQRSTUVWXYZ-",
      tessedit_pageseg_mode: "6"
    };

    // å…¨åœ–ç¸®ä¸€ä¸‹åŠ é€Ÿï¼ˆä¸å½±éŸ¿å¤§éƒ¨åˆ†æ¨™ç±¤ï¼‰
    const base = downscaleIfNeeded(workCanvasFull, 2200);
    const enhBase = enhanceForOcr(base, 1.7, 170);

    const angles = [0, 90, 180, 270];

    for (const deg of angles) {
      const feedRaw = (deg===0) ? base : rotateCanvas(base, deg);
      const feedEnh = (deg===0) ? enhBase : rotateCanvas(enhBase, deg);

      // Debug preview
      document.getElementById('imgOcrRaw').src = canvasToPreviewURL(makeThumb(feedRaw, 420, 420));
      document.getElementById('imgOcrEnh').src = canvasToPreviewURL(makeThumb(feedEnh, 420, 420));

      // RAW
      setStatus(`ğŸ§¾ OCR å…¨åœ–ï¼ˆRAWï¼‰${deg}Â°...`);
      let textRaw = "";
      try {
        const ret = await worker.recognize(canvasToJpegURL(feedRaw, 0.95), opts);
        textRaw = normalizeTextKeepParens(ret?.data?.text || "");
      } catch(e) { textRaw = ""; }
      debug.push(`[OCR][RAW][${deg}] ${compact(textRaw).slice(0,240)}${compact(textRaw).length>240?'...':''}`);
      if (textRaw && hasGS1Core(textRaw)) {
        debug.push(`[OCR][BEST] RAW @ ${deg}`);
        return { text: textRaw, cand: `FULL_RAW`, deg };
      }

      // ENH
      setStatus(`ğŸ§¾ OCR å…¨åœ–ï¼ˆENHï¼‰${deg}Â°...`);
      let textEnh = "";
      try {
        const ret = await worker.recognize(canvasToJpegURL(feedEnh, 0.95), opts);
        textEnh = normalizeTextKeepParens(ret?.data?.text || "");
      } catch(e) { textEnh = ""; }
      debug.push(`[OCR][ENH][${deg}] ${compact(textEnh).slice(0,240)}${compact(textEnh).length>240?'...':''}`);
      if (textEnh && hasGS1Core(textEnh)) {
        debug.push(`[OCR][BEST] ENH @ ${deg}`);
        return { text: textEnh, cand: `FULL_ENH`, deg };
      }
    }

    debug.push(`[OCR][BEST] -`);
    return { text:"", cand:"", deg:null };
  }

  // ===== Main analyze =====
  async function analyzeFromWorkCanvas({ forceOcr=false } = {}) {
    loader.style.display = "block";
    const debug = [];
    debug.push(`WASM_URL: /zxing_reader.wasm`);

    document.getElementById('imgWorkThumb').src = canvasToPreviewURL(makeThumb(workCanvas, 420, 420));

    // å¤§ROIï¼ˆZXing å¿«é€Ÿç”¨ï¼‰
    const rect = getBigRoiRect(0.52);
    const bigCrop = cropCanvas(rect, 2.0);
    document.getElementById('imgScanCrop').src = canvasToPreviewURL(makeThumb(bigCrop, 420, 420));

    // 1) ZXingï¼ˆé™¤é force OCRï¼‰
    if (!forceOcr) {
      setStatus("ğŸ“¡ ZXingï¼šå¤§ROI æƒæï¼ˆå¿«ï¼‰...");
      const z = await zxingScanBig(bigCrop, debug);
      if (z.text) {
        document.getElementById('imgZxingFeed').src = canvasToPreviewURL(makeThumb(z.feedCanvas, 420, 420));
        document.getElementById('imgOcrRaw').src = "";
        document.getElementById('imgOcrEnh').src = "";
        return {
          source: `ZXING_${z.cand}_${z.deg}`,
          raw: z.text,
          data: extractGS1Data(z.text),
          debug_text: debug.join("\n")
        };
      }
    }

    // 2) OCR å…¨åœ– + æ—‹è½‰ï¼ˆä¿åº•ï¼‰
    setStatus("âš ï¸ ZXing æœªè§£åˆ°ï¼Œæ”¹ç”¨ OCR å…¨åœ–æ—‹è½‰ä¿åº•...");
    document.getElementById('imgZxingFeed').src = "";
    const o = await ocrFullImageRotate(workCanvas, debug);

    return {
      source: o.text ? `OCR_${o.cand}_${o.deg}` : "OCR_NONE",
      raw: o.text || "",
      data: extractGS1Data(o.text || ""),
      debug_text: debug.join("\n")
    };
  }

  async function triggerAnalysisFromBase64(base64, { forceOcr=false } = {}) {
    loader.style.display = 'block';
    setStatus("âŒ› æ­£åœ¨æº–å‚™åˆ†æ...");

    await drawBase64ToWorkCanvas(base64);

    const result = await analyzeFromWorkCanvas({ forceOcr });
    const data = result.data || { gtin:"", exp:"", lot:"" };

    document.getElementById('rawAll').value =
      [
        `=== SOURCE: ${result.source} ===`,
        result.debug_text || "",
        result.raw ? `\n[RAW_TEXT]\n${result.raw}` : ""
      ].filter(Boolean).join("\n");

    showSourcePill(result.source);

    // âœ… ä½ è¦çš„æ¬„ä½ï¼š
    // - GTIN(01) å¾Œé¢ 14 ç¢¼ â†’ editGtin â†’ æœ€å¾Œå¯«å…¥ item_uuid
    // - EXP(17) 6 ç¢¼ â†’ è½‰ yyyyå¹´mmæœˆddæ—¥ â†’ editExp
    // - LOT(21) â†’ editLot
    document.getElementById('editGtin').value = data.gtin || "";
    document.getElementById('editExp').value  = data.exp ? yymmddToZhDate(data.exp) : "";
    document.getElementById('editLot').value  = data.lot || "";

    loader.style.display = 'none';
    document.getElementById('reviewArea').style.display = 'block';

    const ok = (document.getElementById('editGtin').value && document.getElementById('editExp').value);
    setStatus(
      ok
        ? `è¾¨è­˜å®Œæˆï¼ˆä¾†æºï¼š${result.source}ï¼‰ï¼Œè«‹è¤‡æ ¸è³‡æ–™ã€‚`
        : `âš ï¸ æœªæŠ“åˆ°å®Œæ•´ GTIN/EXPï¼Œå»ºè­°é‡æ‹æˆ–äººå·¥ä¿®æ­£ã€‚ï¼ˆä¾†æºï¼š${result.source}ï¼‰`
    );
  }

  // ===== Auto tracking loop (ZXing only; OCR after 3 fails -> auto pop review) =====
  function startAutoTrack() {
    stopAutoTrack();
    autoBusy = false;
    autoFound = false;
    zxingFailCount = 0;

    autoTimer = setInterval(async () => {
      if (autoBusy || autoFound) return;
      if (!video.videoWidth || !video.videoHeight) return;
      if (document.getElementById('reviewArea').style.display === 'block') return;

      autoBusy = true;
      try {
        // capture current frame
        workCanvas.width = video.videoWidth;
        workCanvas.height = video.videoHeight;
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, workCanvas.width, workCanvas.height);
        ctx.drawImage(video, 0, 0, workCanvas.width, workCanvas.height);

        // quick try ZXing
        const rect = getBigRoiRect(0.52);
        const bigCrop = cropCanvas(rect, 1.5);

        let zText = "";
        try {
          const z = await zxingScanBig(bigCrop, null);
          zText = z?.text || "";
        } catch(e) { zText = ""; }

        if (zText && hasGS1Core(zText)) {
          autoFound = true;
          stopAutoTrack();
          const base64 = workCanvas.toDataURL('image/jpeg', 0.92);
          preview.src = base64;
          prepareUIForAnalysis();

          stopStream();
          await triggerAnalysisFromBase64(base64, { forceOcr:false });
          return;
        }

        zxingFailCount++;
        if (zxingFailCount < ZXING_FAIL_THRESHOLD_FOR_OCR) {
          setStatus(`ğŸ” è‡ªå‹•è¿½è¹¤ä¸­â€¦ï¼ˆZXing å¤±æ•— ${zxingFailCount}/${ZXING_FAIL_THRESHOLD_FOR_OCR}ï¼‰æ¢ç¢¼æ”¾æ»¿æ¡†ã€é¿å…åå…‰ã€‚`);
        } else {
          // âœ… ZXing é€£çºŒå¤±æ•— 3 æ¬¡ â†’ ç›´æ¥è·‘ OCR ä¿åº•ï¼Œå‘½ä¸­å°±è‡ªå‹•å½ˆå‡ºè¤‡æ ¸
          setStatus("ğŸ§¾ ZXing é€£çºŒå¤±æ•—ï¼Œæ”¹ç”¨ OCR å…¨åœ–ä¿åº•ä¸­â€¦");
          autoFound = true;
          stopAutoTrack();

          const base64 = workCanvas.toDataURL('image/jpeg', 0.92);
          preview.src = base64;
          prepareUIForAnalysis();

          stopStream();
          await triggerAnalysisFromBase64(base64, { forceOcr:true });
          return;
        }
      } finally {
        autoBusy = false;
      }
    }, AUTO_INTERVAL_MS);
  }

  // ===== Camera / UI =====
  async function startCamera() {
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment", width: { ideal: 1920 } }
      });
      video.srcObject = stream;

      document.getElementById('displayArea').style.display = 'block';
      document.getElementById('modeSelect').style.display = 'none';
      document.getElementById('btnSnap').style.display = 'block';
      document.getElementById('guidelines').style.display = 'block';
      video.style.display = 'block';
      preview.style.display = 'none';

      setStatus("ğŸ” è‡ªå‹•è¿½è¹¤ä¸­ï¼šå…ˆè·‘ ZXingï¼›é€£çºŒå¤±æ•— 3 æ¬¡æœƒè‡ªå‹•æ”¹ OCR ä¿åº•ä¸¦å½ˆå‡ºè¤‡æ ¸ã€‚ä¹Ÿå¯æŒ‰æ‹ç…§ã€‚");
      startAutoTrack();
    } catch(e) {
      alert("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—ï¼Œè«‹ç¢ºèªæ¬Šé™");
    }
  }

  async function handleFileUpload(e) {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const base64 = await fileToBase64(file);
    preview.src = base64;
    prepareUIForAnalysis();
    try { await triggerAnalysisFromBase64(base64, { forceOcr:true }); } // ä¸Šå‚³ç›´æ¥ç”¨ OCR ä¿åº•æ¯”è¼ƒç©©
    catch(err){ alert("è¾¨è­˜ç™¼ç”ŸéŒ¯èª¤: " + err.message); location.reload(); }
  }

  async function takeSnapshot() {
    if (!video.videoWidth || !video.videoHeight) {
      alert("ç›¸æ©Ÿå°šæœªå°±ç·’ï¼Œè«‹ç­‰ç•«é¢å‡ºç¾å¾Œå†æ‹ç…§");
      return;
    }

    stopAutoTrack();

    workCanvas.width = video.videoWidth;
    workCanvas.height = video.videoHeight;

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, workCanvas.width, workCanvas.height);
    ctx.drawImage(video, 0, 0, workCanvas.width, workCanvas.height);

    const base64 = workCanvas.toDataURL('image/jpeg', 0.92);

    preview.src = base64;
    prepareUIForAnalysis();
    try { await triggerAnalysisFromBase64(base64, { forceOcr:false }); }
    catch(err){ alert("è¾¨è­˜ç™¼ç”ŸéŒ¯èª¤: " + err.message); location.reload(); }
  }

  function prepareUIForAnalysis() {
    stopAutoTrack();
    video.style.display = 'none';
    preview.style.display = 'block';
    document.getElementById('displayArea').style.display = 'block';
    document.getElementById('modeSelect').style.display = 'none';
    document.getElementById('btnSnap').style.display = 'none';
    document.getElementById('guidelines').style.display = 'none';
    document.getElementById('sourcePill').style.display = 'none';
  }

  // ===== Submit =====
  async function finalSubmit() {
    const qty = parseInt(document.getElementById('editQty').value, 10);

    // âœ… ä½ æŒ‡å®šï¼šGTIN è¦å¡é€²è³‡æ–™åº« item_uuid
    const gtin = (document.getElementById('editGtin').value || "").trim();
    const expZh = (document.getElementById('editExp').value || "").trim();
    const lot21 = (document.getElementById('editLot').value || "").trim();

    if (!gtin) { alert("â— GTIN (01) ä¸èƒ½ç©ºç™½"); return; }
    if (!expZh) { alert("â— æœ‰æ•ˆæ—¥æœŸä¸èƒ½ç©ºç™½"); return; }

    const payload = {
      item_uuid: gtin,
      expiry_date: expZh,        // yyyyå¹´mmæœˆddæ—¥
      lot_21: lot21,             // ä½ å¦‚æœå¾Œç«¯æ²’æ”¶ä¹Ÿæ²’é—œä¿‚ï¼ˆå¯ç•™ä½œæ“´å……ï¼‰
      quantity: qty,
      from_loc: 'FACTORY', to_loc: 'MAIN', operator: 'MANUAL_REVIEW'
    };

    loader.style.display = 'block';
    const res = await fetch('/api/stock', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (res.ok) {
      alert("âœ… åŒ¯å…¥æˆåŠŸï¼å·²å­˜å…¥ " + qty + " ä»¶ç‰©æ–™ã€‚");
      location.href = 'index.html';
    } else {
      const err = await res.json().catch(() => ({message: "é€£ç·šç•°å¸¸"}));
      alert("âŒ å¤±æ•—: " + err.message);
      loader.style.display = 'none';
    }
  }
</script>
</body>
</html>
